---
title: "Vulnerability of soil function indicators to severe wildfires"
author: "Amara Santiesteban Serrano"
date: " r format(Sys.time(), '%d %B, %Y') "
output: 
  html_document:
    df_print: paged
    pdf_document: default
    word_document: default
  editor_options:
    chunk_output_type: inline
---

The code is structured in the same order as the results of the article

```{r Packages}
#install.packages("pacman")
pacman::p_load("ggplot2","tidyr","dplyr","tidyverse","readxl","pastecs","lattice","forcats","corrgram","corrplot","HH","effects","car","multcompView","lme4","emmeans","factoextra","ggfortify","RColorBrewer","MuMIn","scales","multifunc", "ggthemes", "knitr", "vegan", "hrbrthemes", "indicspecies", "GGally", "rpart", "rpart.plot", 
               "irr", "evtree", "randomForest")

#devtools::install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis)
#devtools::install_github("arleyc/PCAtest")
library(PCAtest)
```

```{r Read data}
dataset <- Firefungi_soil_dataset_2021
#summary(dataset)

# Unit transformation
dataset <- dataset %>% 
  mutate(Fe_g_Kg = Fe_mg_Kg_105/1000,
         Ergosterol_µg_g = Ergosterol_ng_g_105/1000,
         C_N_ratio = Ctotal_g_100g_105/Ntotal_g_100g_105)

# Subset by depth
dataset_topsoil <- dataset %>%  filter(DEPTH=="topsoil")
dataset_subsoil <- dataset %>% filter(DEPTH=="subsoil")
```

```{r Correlation Matrix}
vars_cor <- dataset[,c(31:51)]
ggcorr(vars_cor, method = c("everything", "pearson"))
#ggsave("vars_cor.png")
```

```{r Descriptive table of numeric variables}
dataset$ID <- as.character(dataset$ID)
dataset$PLOT <- as.character(dataset$PLOT)
dataset$SITE <- as.character(dataset$SITE)

se <- function(x) {
  sd(x) / sqrt(length(x))
}

descrip <- function(dataset) {
  result <- dataset %>%
    dplyr::group_by(TRAT2, DEPTH) %>%
    dplyr::summarize(across(where(is.numeric), list(
      mean = ~mean(.),
      se = ~se(.)),
      .names = "{col}_{fn}"))

  return(result)
}
descrip <- descrip(dataset)
#write.csv(descrip, "output/descriptive_table.csv")
```

```{r Colors}
cols <- c("#41b6c4","#fd8d3c","#cb181d","#800026")
```

                           *ABOVEGROUND CHARACTERIZATION*
                           
*PCA analysis*
- Most used for environmental (abiotic) data
- This data must be continuous
- The aim is to reduce dimensions
- Based on Euclidean distances

```{r PCA - plot characterizarion }
#Variables considered in this analysis are plot slope, canopy cover percentages, ground cover percentages and depth of the organic layer (both charred and non-charred):

plot_vars <- c("Slope_per","Organic_layer_mean_depth_cm", "Charred_organic_layer_mean_cm", "Green_per", "Brown_per", "Consumed_per", "Grass_per", "Old_litter_per", "New_litter_per", "Mineral_per", "Ash_per", "Stone_per")

pca_sev <- prcomp(dataset[,plot_vars], scale=T)
summary(pca_sev)

pc1_loadings <- pca_sev$rotation[,1] #how much each original variable contributes to the first principal component (PC1)
sorted_loadings <- abs(pc1_loadings)[order(abs(pc1_loadings), decreasing = TRUE)]

# Plot customization (FIGURE 2)
dataset$TRAT2 <- ordered(dataset$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
pca_plot <- fviz_pca_biplot(pca_sev,
                geom.var = c("arrow","text"),
                mean.point = FALSE, # No centroids
                label = "none",
                col.var = "#696969", alpha.var = 0.3,
                pointsize = 6, alpha.ind = 0.4, 
                pointshape = 16,
                col.ind = dataset$TRAT2, shape.ind = "21",
                palette = cols,
                repel = TRUE,
                addEllipses = TRUE,
                ellipse.type = "confidence",
                ellipse.level = 0.99,  # confident %
                ellipse.alpha = 0.2,
                ellipse.size = 5, #thickness
                ellipse.order = 1, # Draw ellipses first (under the points)
                ggtheme = theme_base()) +
  theme(legend.position = "none") +
  scale_x_reverse()+ #We want a fire severity gradient from UB -> HS
  xlab("PC1 (40.4%)") + 
  ylab("PC2 (23%)") 
#ggsave("output/Figure2.png")

pca_plot
summary(pca_sev) 
pc1 <- pca_sev$x[,1] 
pc1 <- as.data.frame(pc1)
#write.csv(pc1, file = "pc1.csv")

## PCA by depths
pca_sev_top <- prcomp(dataset_topsoil[,c(11,19:29)], scale=T)
pc1_top <- pca_sev_top$x[,1] 

pca_sev_sub <- prcomp(dataset_subsoil[,c(11,19:29)], scale=T)
pc1_sub <- pca_sev_sub$x[,1]

##### Linear models
var <- dataset_subsoil$Clay_per

lm <- aov(var ~ TRAT2, data = dataset_subsoil)
summary(lm)
anova(lm)
Tuckeys<- TukeyHSD(lm)

cld <- multcompLetters4(lm, Tuckeys)
print(cld) 
```

```{r Include pc1 in the dataset and simplify it}
# Select only response variables (24 soil indicators)
resp_variables <- names(dataset) %>% 
  intersect(c("pH", "EC", "Bulk_density_g_cm3", "C_N_ratio",
              "A_phosphorus_ppm_105", "Phosphatase_activity_µmol_g_h", 
              "NH4_mgL_105","NO3_mgL_105", "Ergosterol_µg_g", 
              "Ntotal_g_100g_105", "Ctotal_g_100g_105", "Carbon_stock_Mg_ha",
              "Nitrogen_stock_Mg_ha", "SOM_per_corregido", "MBC_mg_kg_105",
              "Nematode_g_105", "Ca_g_kg", "K_g_kg","Mg_g_kg", "Na_g_kg", 
              "Al_g_kg", "Fe_g_Kg","Zn_mg_Kg_105", "Cu_mg_Kg_105"))

dataset_simple <- dataset %>%
  dplyr::select(ID, SITE, TRAT2, DEPTH, all_of(resp_variables))

#Add pc1 values to the dataframe
dataset_pc1 <- dataset_simple %>%
  dplyr::mutate(pc1 = pc1$pc1)
```

                           *BELOWGROUND CHARACTERIZATION*
                           
```{r Exploratory analysis of response variables}
var <- dataset_pc1$Cu_mg_Kg_105
var_log <- (log(dataset_pc1$Ergosterol_µg_g)+1)

#Visually assessment of data

hist(var) 

dataset_pc1 %>%
  ggplot(aes(x=TRAT2, y=var, fill=DEPTH)) +
  geom_boxplot(outlier.color = "red",
    outlier.shape = 8) +
  scale_fill_brewer(palette="Dark2") +
  stat_summary(fun= mean, geom="point", shape=20, size=2, colour="black") + 
  facet_wrap(~ DEPTH, scales="free_x") 
```
 
 - *Log-transformed variables to fit the models*: EC, NH4, NO3, Ca, Mg, Total C, Carbon stock, Nitrogen stock, MBC, Ergosterol, C/N ratio
 
```{r Linear Mixed Models}
#### FIRST!! We define the Contrast table we want to work with
options(contrasts=c(factor="contr.sum", ordered="contr.poly"))
##############################################################
mixed.var <- lmer(var ~ TRAT2*DEPTH + (1|SITE), data = dataset_pc1)
mixed.null <- lmer(var ~ (1|SITE), data = dataset_pc1)
anova(mixed.var)
summary(mixed.var)
plot(mixed.var)

par(mfrow=c(1,3))
qqnorm(resid(mixed.var)); qqline(resid(mixed.var))
hist(resid(mixed.var))
plot(fitted(mixed.var), resid(mixed.var)); abline(h=0)
par(mfrow=c(1,1))

car::Anova(mixed.var, test.statistic="F", type=3)
AICc(mixed.var)

dotplot(ranef(mixed.var), conVar=TRUE) #Influence of random effects

multcomp::cld(emmeans(mixed.var, ~TRAT2*DEPTH, type="response"), Letters=letters) #Tuckey's post-hoc test
```

```{r Linear Mixed Models by depth: TOPSOIL}
models_topsoil <- dataset_pc1 %>% filter(DEPTH=="topsoil")
var_top <- models_topsoil$Cu_mg_Kg_105
var_log_top <- (log(models_topsoil$Ergosterol_µg_g)+1)

hist(var_log_top)

## TRAT2 as fixed effect

mixed.TRAT2_05 <- lmer(var_top ~ TRAT2 + (1|SITE), data = models_topsoil)

par(mfrow=c(1,3))
qqnorm(resid(mixed.TRAT2_05)); qqline(resid(mixed.TRAT2_05))
hist(resid(mixed.TRAT2_05))
plot(fitted(mixed.TRAT2_05), resid(mixed.TRAT2_05)); abline(h=0)
par(mfrow=c(1,1))

car::Anova(mixed.TRAT2_05, test.statistic="F", type=3)

multcomp::cld(emmeans(mixed.TRAT2_05, ~TRAT2, type="response"), Letters=letters) #Tuckey's post-hoc test

```

```{r Linear Mixed Models by depth: SUBSOIL}
models_subsoil <- dataset_pc1 %>% filter(DEPTH=="subsoil")
var_sub <- dataset_subsoil$Cu_mg_Kg_105
var_log_sub <- (log(models_subsoil$Ergosterol_µg_g)+1)

hist(var_log_sub)

## TRAT2 as fixed effect

mixed.TRAT2_510 <- lmer(var_sub ~ TRAT2 + (1|SITE), data = models_subsoil)

par(mfrow=c(1,3))
qqnorm(resid(mixed.TRAT2_510)); qqline(resid(mixed.TRAT2_510))
hist(resid(mixed.TRAT2_510))
plot(fitted(mixed.TRAT2_510), resid(mixed.TRAT2_510)); abline(h=0)
par(mfrow=c(1,1))

car::Anova(mixed.TRAT2_510, test.statistic="F", type=3)

multcomp::cld(emmeans(mixed.TRAT2_510, ~TRAT2, type="response"), Letters=letters) #Tuckey's post-hoc test
```

```{r t-test HS1 vs HS2}
severity_data <- dataset %>%
  filter(TRAT2 %in% c("HS1", "HS2"))

var <- subset_data$A_phosphorus_ppm_105

ttest_result <- t.test(var ~ TRAT2, data = severity_data)
print(ttest_result)

lm_f <- aov(var ~ TRAT2, data = severity_data)
summary(lm_f)
anova(lm_f)
Tuckeys<- TukeyHSD(lm_f)
print(Tuckeys)

cld <- multcompLetters4(lm_f, Tuckeys)
print(cld) 
```

*ORDINATIONS*

```{r Ordination matrix}
#These analysis are sensitive to the scale of the different response variables so the first thing we do is to standardize the response variables if they are not in the same units. It is recommended to do the transformations before entering our data in the *metaMDS* function, because this function would standardize our a data if we don't set autotransform = FALSE:
ordination_df <- dataset_simple %>%
  mutate(across(all_of(resp_variables),           
                ~ rescale(., to=c(0,1)),            
                .names = "{.col}_standardized"))

ordination_df0 <- ordination_df %>%
  dplyr::select(ends_with("_standardized"))

#Topsoil:
ordination_df_topsoil <- ordination_df %>% 
  filter(DEPTH=="topsoil") %>%
  dplyr::select(all_of(ends_with("_standardized"))) 

#Subsoil:
ordination_df_subsoil <- ordination_df %>% 
  filter(DEPTH=="subsoil") %>%
  dplyr::select(all_of(ends_with("_standardized"))) 
```

*NMDS Overview*
- We can use the vegdist function to calculate our distance matrix if we need it for further analysis, but the metaMDS function will automatically calculate the distance matrix based on the type of distance we choose.

ordination_dist <- vegdist(ordination_df0, distance="euclidean")

- The solutions for NMDS depend on how many dimensions we select. It's important to find a balance between the level of stress and the complexity of the model.
- Indicator Species Analysis: This method helps identify species (or variables) that are closely associated with a specific group.

-Guideline for plotting in ggplot: 
1) Extract the NMDS scores from the ordination and create a dataframe with it 
2) Add all of the underlying environmental data into this new NMDS dataframe
3) Conduct the Indicator Species Analysis and make a new dataframe with the selected species (variables in this case), and their NMDS scores

```{r NMDS + environmental var}
set.seed(123)
nmds<-metaMDS(ordination_df0, distance="euclidean", autotransform=FALSE, k=2)

coordenadas <- as.data.frame(scores(nmds)$sites) 
variables <- as.data.frame(scores(nmds, "species"))

coordenadas <- coordenadas %>%
  mutate(DEPTH = as.factor(dataset$DEPTH),
         TRAT2 = as.factor(dataset$TRAT2))

#Add enviromental data
env_df <- dataset %>%
  dplyr::select(all_of(plot_vars))

env <- envfit(nmds, env_df, permutations = 999, na.rm = TRUE)

env_coord0 <- as.data.frame(scores(env, "vectors"))
env_coord_sig0 <- scores(env, "vectors")[env$vectors$pvals < 0.05, ] #Significant environmental vectors

#Visualization
metadata_nmds <- inner_join(dataset, coordenadas, by=c("TRAT2"))

centroid <- metadata_nmds %>%
  group_by(TRAT2) %>%
  summarize(axis1 = mean(NMDS1), #This will create the centroids
            axis2 = mean(NMDS2))

star <- metadata_nmds %>%
  left_join(centroid_top, by = "TRAT2") %>%
  rename(centroid1 = axis1, centroid2 = axis2)  # Rename centroids for plotting

centroid_top$TRAT2 <- ordered(centroid_top$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
star_top$TRAT2 <- ordered(star_top$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

  #Plot (Figure S2)
ggplot(star, aes(x=NMDS1, xend=centroid1, 
                 y=NMDS2, yend=centroid2, color=TRAT2)) +
  geom_point(size=1, alpha=0.1) +
  geom_segment(alpha=0.1) +
  geom_point(data=centroid, mapping = aes(x=axis1, y=axis2, color=TRAT2), shape=19,
  alpha=0.9, size=5, inherit.aes = FALSE) +
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
               data = env_coord_sig0, size =1.1, alpha=0.7, color = "#737373",
               arrow=arrow(length=unit(0.02, "npc"))) +
  #geom_text(data = env_coord_sig0, aes(x = 2*NMDS1, y = 2*NMDS2), colour = "grey30", label = row.names(env_coord_sig0), inherit.aes = FALSE) + 
  scale_color_manual(values=cols) +
  scale_fill_manual(values=cols) +
  theme_minimal()+
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("output/FigureS2.png", height = 5, width = 7, dpi = 300)
```

```{r NMDS Topsoil}
set.seed(123)
nmds_top<-metaMDS(ordination_df_topsoil, distance="euclidean", autotransform=FALSE, k=2)
print(nmds_top)
stressplot(nmds_top)

coordenadas_top <- as.data.frame(scores(nmds_top)$sites) 
variables_top <- as.data.frame(scores(nmds_top, "species"))

coordenadas_top <- coordenadas_top %>%
  mutate(DEPTH = as.factor(dataset_topsoil$DEPTH),
         TRAT2 = as.factor(dataset_topsoil$TRAT2))

# Indicator species analysis
set.seed(42)
nmds_top.ISA <- multipatt(x = ordination_df_topsoil,
cluster = dataset_topsoil$TRAT2,
duleg = TRUE)
summary(nmds_top.ISA)

top_sig_species <- rownames(nmds_top.ISA$sign)  # Get names of significant species
top_species_df <- ordination_df_topsoil %>%
  dplyr::select(all_of(top_sig_species))
env_species_top <- envfit(nmds_top, top_species_df, permutations=999, na.rm=TRUE)
env_species_coord <- as.data.frame(scores(env_species_top, "vectors"))

env_species_coord_sig <- env_species_coord[c("EC_standardized", "C_N_ratio_standardized",
              "Phosphatase_activity_µmol_g_h_standardized", 
              "NO3_mgL_105_standardized", "Ergosterol_µg_g_standardized", 
              "MBC_mg_kg_105_standardized","Nematode_g_105_standardized"),]

#Visualization
metadata_nmds_top <- inner_join(dataset_simple, coordenadas_top, by=c("TRAT2", "DEPTH"))

centroid_top <- metadata_nmds_top %>%
  filter(DEPTH=="topsoil") %>%
  group_by(TRAT2) %>%
  summarize(axis1 = mean(NMDS1), #This will create the centroids
            axis2 = mean(NMDS2))

star_top <- metadata_nmds_top %>%
  filter(DEPTH == "topsoil") %>%  
  left_join(centroid_top, by = "TRAT2") %>%
  rename(centroid1 = axis1, centroid2 = axis2)  # Rename centroids for plotting

centroid_top$TRAT2 <- ordered(centroid_top$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
star_top$TRAT2 <- ordered(star_top$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

  #Plot (Figure 3a)
ggplot(star_top, aes(x=NMDS1, xend=centroid1, 
                 y=NMDS2, yend=centroid2, color=TRAT2)) +
  stat_ellipse(aes(fill = TRAT2), geom = "polygon", level = 0.7, alpha = 0.1) +
  geom_point(data=centroid_top, mapping = aes(x=axis1, y=axis2, color=TRAT2), shape=19,
  alpha=0.9, size=5, inherit.aes = FALSE) +
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
               data = env_species_coord_sig, size =1.1, alpha=0.7, color = "#737373",
               arrow=arrow(length=unit(0.02, "npc"))) +
  geom_text(data = env_species_coord_sig, aes(x = 2*NMDS1, y = 2*NMDS2), colour = "grey30", label = row.names(env_species_coord_sig), inherit.aes = FALSE) + 
  #geom_point(size=4, alpha=0.07) +
  #geom_segment(alpha=0.07) +
  scale_color_manual(values=cols) +
  scale_fill_manual(values=cols) +
  theme_minimal()+
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("output/Figure3a_top.png", height = 5, width = 7, dpi = 300)

  #Plot (Figure 3b)
ggplot(star_top, aes(x = NMDS1, xend = centroid1, 
                      y = NMDS2, yend = centroid2, color = TRAT2)) +
  geom_segment(aes(color = TRAT2), alpha = 0.07) +  
  geom_point(size = 3.5, alpha = 0.8) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("output/Figure3b_top.png", height = 5, width = 7, dpi = 300)
```

```{r NMDS Subsoil}
set.seed(123)
nmds_sub <-metaMDS(ordination_df_subsoil, distance="euclidean", autotransform=FALSE, k=2)
print(nmds_sub)
coordenadas_sub <- as.data.frame(scores(nmds_sub)$sites) 
variables_sub <- as.data.frame(scores(nmds_sub, "species"))

coordenadas_sub <- coordenadas_sub %>%
  mutate(DEPTH = as.factor(dataset_subsoil$DEPTH),
         TRAT2 = as.factor(dataset_subsoil$TRAT2))

# Indicator species analysis
set.seed(42)
nmds_sub.ISA <- multipatt(x = ordination_df_subsoil,
cluster = dataset_subsoil$TRAT2,
duleg = TRUE)
summary(nmds_sub.ISA)

sub_sig_species <- rownames(nmds_sub.ISA$sign)  # Get names of significant species
sub_species_df <- ordination_df_subsoil %>%
  dplyr::select(all_of(sub_sig_species))
env_species_sub <- envfit(nmds_sub, sub_species_df, permutations=999, na.rm=TRUE)
env_species_coord <- as.data.frame(scores(env_species_sub, "vectors"))

env_sub_coord_sig <- env_species_coord[c("EC_standardized", "C_N_ratio_standardized",
              "NH4_mgL_105_standardized", "Bulk_density_g_cm3_standardized",
              "NO3_mgL_105_standardized"),]

## 
sub_functions <- soil_functions_clean_top[,c(4,6,8,12,14)]
env_functions_sub <- envfit(nmds_sub, sub_functions, permutations=999, na.rm=TRUE)
env_functions_coord <- as.data.frame(scores(env_functions_sub, "vectors"))

##
env_pc1 <- envfit(nmds_sub, pc1_sub, permutations=999, na.rm=TRUE)
env_pc1_coord <- as.data.frame(scores(env_pc1, "vectors"))

#Visualization
metadata_nmds_sub <- inner_join(dataset_simple, coordenadas_sub, by=c("TRAT2", "DEPTH"))

centroid_sub <- metadata_nmds_sub %>%
  dplyr::filter(DEPTH=="subsoil") %>%
  dplyr::group_by(TRAT2) %>%
  dplyr::summarize(axis1 = mean(NMDS1), #This will create the centroids
            axis2 = mean(NMDS2))

star_sub <- metadata_nmds_sub %>%
  filter(DEPTH == "subsoil") %>%  
  left_join(centroid_sub, by = "TRAT2") %>%
  rename(centroid1 = axis1, centroid2 = axis2)  

centroid_sub$TRAT2 <- ordered(centroid_sub$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
star_sub$TRAT2 <- ordered(star_sub$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

  #Plot (Figure 3a)
ggplot(star_sub, aes(x=NMDS1, xend=centroid1, 
                 y=NMDS2, yend=centroid2, color=TRAT2)) +
  stat_ellipse(aes(fill = TRAT2), geom = "polygon", level = 0.7, alpha = 0.05) +
  geom_point(data=centroid_sub, mapping = aes(x=axis1, y=axis2, color=TRAT2), shape=19,
  alpha=0.9, size=5, inherit.aes = FALSE) +
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
               data = env_sub_coord_sig, size =1.1, alpha=0.7, color = "#737373",
               arrow=arrow(length=unit(0.02, "npc"))) +
  geom_text(data = env_sub_coord_sig, aes(x = 2*NMDS1, y = 2*NMDS2), colour = "grey30", label = row.names(env_sub_coord_sig), inherit.aes = FALSE) + 
  #geom_point(size=4, alpha=0.07) +
  #geom_segment(alpha=0.07) +
  scale_color_manual(values=cols) +
  scale_fill_manual(values=cols) +
  theme_minimal()+
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("output/Figure3a_sub.png", height = 5, width = 7, dpi = 300)

  #Plot (Figure 3b)
ggplot(star_sub, aes(x = NMDS1, xend = centroid1, 
                      y = NMDS2, yend = centroid2, color = TRAT2)) +
  geom_segment(aes(color = TRAT2), alpha = 0.2) +  
  geom_point(size = 3.5, alpha = 0.6) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("output/Figure3b_sub.png", height = 5, width = 7, dpi = 300)
```

```{r PERMANOVA - NMDS }
#Topsoil
top_dist <- vegdist(ordination_df_topsoil, distance="euclidean") #distance matrix
set.seed(43)
top_permanova <- adonis2(top_dist~TRAT2, dataset_topsoil, permutations = 999)
top_pairwise <- pairwiseAdonis::pairwise.adonis2(top_dist~TRAT2, data = dataset_topsoil) #pairwise adonis:
top_permanova
top_pairwise

#Subsoil
sub_dist <- vegdist(ordination_df_subsoil, distance="euclidean") #distance matrix
set.seed(43)
sub_permanova <- adonis2(sub_dist~TRAT2, dataset_subsoil, permutations = 999, method = "euclidean")
sub_pairwise <- pairwiseAdonis::pairwise.adonis2(sub_dist~TRAT2, data = dataset_subsoil)#pairwise adonis:
sub_permanova
sub_pairwise
```

```{r Soil functions}
# 1) Normalization of variables (resp_variables)
std_response <- dataset_simple %>%
  mutate(across(all_of(resp_variables),           
                ~ rescale(., to=c(0,1)),            
                .names = "{.col}_standardized"))

# 2) Create the 6 "soil function" categories with their mean and standard error: Soil_properties, Nutrient_pools, Soil_carbon, Soil_activity, Heavy_metals, Soil_biota:
soil_functions <- std_response %>%
  dplyr::group_by(ID,TRAT2, DEPTH) %>% #We need to include ID because we want an individual value of Soil Function per sample
  dplyr::mutate(
    Soil_properties = mean(c(pH_standardized, EC_standardized, Bulk_density_g_cm3_standardized), na.rm = TRUE),
    Soil_fertility = mean(c(A_phosphorus_ppm_105_standardized, NH4_mgL_105_standardized, NO3_mgL_105_standardized, Ntotal_g_100g_105_standardized, Nitrogen_stock_Mg_ha_standardized, C_N_ratio_standardized, Ca_g_kg_standardized, K_g_kg_standardized, Mg_g_kg_standardized, Na_g_kg_standardized), na.rm = TRUE),
    Carbon_sequestration = mean(c(Ctotal_g_100g_105_standardized, SOM_per_corregido_standardized, Carbon_stock_Mg_ha_standardized), na.rm = TRUE),
    Nutrient_cycling = mean(c(Phosphatase_activity_µmol_g_h_standardized, MBC_mg_kg_105_standardized), na.rm = TRUE),
    Metals = mean(c(Al_g_kg_standardized, Cu_mg_Kg_105_standardized, Fe_g_Kg_standardized, Zn_mg_Kg_105_standardized), na.rm = TRUE),
    Soil_biodiversity = mean(c(Nematode_g_105_standardized, Ergosterol_µg_g_standardized), na.rm = TRUE))

#### Summarise by fire severity and depth
soil_functions_sum <- soil_functions %>%
dplyr::group_by(TRAT2, DEPTH) %>%
dplyr::summarise(
        SE_soil_properties = se(Soil_properties), #SE before mean because otherwise will try to calculate it over the mean and the outcome will be NAs      
        Soil_properties = mean(Soil_properties),
        SE_Soil_fertility = se(Soil_fertility), 
        Soil_fertility = mean(Soil_fertility),
        SE_Carbon_sequestration = se(Carbon_sequestration), 
        Carbon_sequestration = mean(Carbon_sequestration),
        SE_Nutrient_cycling = se(Nutrient_cycling), 
        Nutrient_cycling = mean(Nutrient_cycling),
        SE_metals = se(Metals), 
        Metals = mean(Metals),
        SE_Soil_biodiversity = se(Soil_biodiversity),
        Soil_biodiversity = mean(Soil_biodiversity)
        )

# 3) Reshape the data from wide to long format to plot it
soil_long <- soil_functions_sum %>%
  pivot_longer(cols = c(Soil_properties, 
                        Soil_fertility, 
                        Carbon_sequestration, 
                        Nutrient_cycling, 
                        Metals, 
                        Soil_biodiversity),
                        names_to = "Soil_function", values_to = "Mean") %>%
  dplyr::select(TRAT2, DEPTH, Soil_function, Mean)
  
soil_long_se <- soil_functions_sum %>%
  pivot_longer(cols = c(SE_soil_properties, 
                        SE_Soil_fertility, 
                        SE_Carbon_sequestration, 
                        SE_Nutrient_cycling, 
                        SE_metals, 
                        SE_Soil_biodiversity),
                        names_to = "SE_function", values_to = "SE") %>%
  dplyr::select(TRAT2, DEPTH,SE)

## Add the SE to the dataframe
soil_long$SE <- soil_long_se$SE

##### Plot preparation
soil_long$Soil_function <- factor(soil_long$Soil_function, 
                           levels = c("Soil_properties", "Soil_fertility",
                                      "Carbon_sequestration", "Nutrient_cycling",
                                      "Soil_biodiversity", "Metals"))
soil_long$TRAT2 <- ordered(soil_long$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
soil_long$DEPTH <- ordered(soil_long$DEPTH, levels=c("topsoil", "subsoil"))

# 4) Plot visualization (FIGURE 4):
ggplot(soil_long, aes(x = TRAT2, y = Mean, fill = TRAT2, alpha=DEPTH)) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), position = position_dodge(0.9), width = 0.25) +
  scale_fill_manual(values = cols) +
  scale_alpha_manual(values = c("topsoil" = 0.8, "subsoil" = 0.5)) +
  facet_grid(Soil_function~DEPTH, scales = "free_x") +  
  labs(x = "Treatment", y = "Mean ± SE") +  # Removed the title from labs
  theme_minimal() +
  theme(
    panel.grid = element_blank(),  # Remove grid lines
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),  # Keep the axis lines
    axis.text = element_text(color = "black"),  # Make axis text black
    axis.ticks = element_line(color = "black"),  # Black axis ticks
    strip.placement = "outside",  # Place facet labels outside the plot
    strip.background = element_blank(),  # Remove facet strip background
    axis.line.x = element_line(color = "black"),  # Ensure the x-axis line shows up in all plots
    legend.position = "none"  # Remove the legend
  )
#ggsave("output/Figure4_color.png", width = 3, height = 7, dpi = 300)

##### Linear models
soil_functions_top <- soil_functions %>%
  filter(DEPTH=="topsoil")

var_func <- soil_functions$Soil_properties

lm_f <- aov(var_func ~ TRAT2*DEPTH, data = soil_functions)
summary(lm_f)
anova(lm_f)
Tuckeys<- TukeyHSD(lm_f)

cld <- multcompLetters4(lm_f, Tuckeys)
print(cld) 
```

```{r Multifunctionality: calculated as Byrnes et al. 2022}
#In this first step we transform four indicators (Heavy Metals) for which lower values mean higher functionality
asduffy <- dataset_pc1 %>%
  dplyr::select(pc1, ID, TRAT2, DEPTH, all_of(resp_variables)) %>%
  dplyr::mutate(Al_g_kg = -1*Al_g_kg + max(Al_g_kg, na.rm=T),
                Fe_g_Kg = -1*Fe_g_Kg + max(Fe_g_Kg, na.rm=T),
                Zn_mg_Kg_105 = -1*Zn_mg_Kg_105 + max(Zn_mg_Kg_105, na.rm=T),
                Cu_mg_Kg_105 = -1*Cu_mg_Kg_105 + max(Cu_mg_Kg_105, na.rm=T))

asduffy <- asduffy %>%
  cbind(getStdAndMeanFunctions(asduffy, resp_variables)) 

asduffy <-asduffy %>%
  getFuncsMaxed(resp_variables,
                threshmin=0.8, threshmax=0.8)

duffyAllVars0.std <- paste0(resp_variables, ".std")

#now effective number of functions
asduffy <- asduffy %>%
  mutate(n_eff_func_1 = eff_num_func(., duffyAllVars0.std, q = 1),
         n_eff_func_2 = eff_num_func(., duffyAllVars0.std, q = 2),
         mf_eff_1 = n_eff_func_1 * meanFunction,
         mf_eff_2 = n_eff_func_2 * meanFunction
  )

  #Plot of all the different multifunctionalities calculated:
asduffy %>%
  dplyr::select(ID, pc1, TRAT2,
         meanFunction, funcMaxed,
         n_eff_func_1, n_eff_func_2,
         mf_eff_1, mf_eff_2) %>%
  pivot_longer(cols = c(meanFunction:mf_eff_2)) %>%
  mutate(name = fct_inorder(name)) %>%
  ggplot(aes(x = pc1, y = value,
             color = TRAT2)) +
  stat_summary(fun.data = mean_se) +
  stat_smooth(method = "lm", color = "grey") +
  facet_wrap(vars(name), ncol = 2, scale = "free_y") +
  scale_color_brewer(palette = "Set3")

asduffy$TRAT2 <- ordered(asduffy$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
asduffy$DEPTH <- ordered(asduffy$DEPTH, levels=c("topsoil", "subsoil"))

  #Plot (Figure 5)
asduffy %>%
  dplyr::select(ID, pc1, DEPTH, TRAT2,
         mf_eff_1) %>%
  ggplot(aes(x = pc1, y = mf_eff_1,
             color = TRAT2)) +
  
  stat_smooth(method = "lm", color = "#969696", alpha=0.2) +
  stat_summary(fun.data = mean_se, size=1, shape=19, alpha=0.7) +
  #geom_point(size = 4, shape = 21, color = "white", alpha=0.8) +  # Set color for the point borders
  scale_color_manual(values = cols) +
  facet_wrap(~DEPTH, ncol = 2, scales = "fixed") +
  theme_minimal()+
  theme(
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank()  # Remove strip background
  ) +
  scale_x_reverse()
#ggsave("output/Figure5.png")
```

```{r Multifunctionality calculated for soil functions}
func_variables <- names(soil_functions) %>% 
  intersect(c("Soil_properties", "Soil_fertility",
              "Carbon_sequestration", "Nutrient_cycling",
              "Soil_biodiversity", "Metals"))

#Add pc1 values to the dataframe
soil_functions$pc1 <- pc1$pc1

asduffy_func <- as.data.frame(soil_functions) %>%
  dplyr::select(pc1, ID, TRAT2, DEPTH, all_of(func_variables))
                
asduffy_func <- asduffy_func %>%
  dplyr::mutate(Metals = 1 - Metals)
  
asduffy_func <- asduffy_func %>%
  cbind(getStdAndMeanFunctions(asduffy_func, func_variables)) 

asduffy_func <-asduffy_func %>%
  getFuncsMaxed(func_variables,
                threshmin=0.7, threshmax=0.7)

duffyAllVars1.std <- paste0(func_variables, ".std")

#now effective number of functions
asduffy_func <- asduffy_func %>%
  mutate(n_eff_func_1 = eff_num_func(., duffyAllVars1.std, q = 1),
         n_eff_func_2 = eff_num_func(., duffyAllVars1.std, q = 2),
         mf_eff_1 = n_eff_func_1 * meanFunction,
         mf_eff_2 = n_eff_func_2 * meanFunction
  )

asduffy_func$TRAT2 <- ordered(asduffy_func$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
asduffy_func$DEPTH <- ordered(asduffy_func$DEPTH, levels=c("topsoil", "subsoil"))

#plot
asduffy_func %>%
  dplyr::select(ID, pc1, DEPTH, TRAT2,
         mf_eff_1) %>%
  ggplot(aes(x = pc1, y = mf_eff_1,
             color = TRAT2)) +
  
  stat_smooth(method = "lm", color = "#969696", alpha=0.2) +
  stat_summary(fun.data = mean_se, size=1, shape=19, alpha=0.7) +
  #geom_point(size = 4, shape = 21, color = "white", alpha=0.8) +  # Set color for the point borders
  scale_color_manual(values = cols) +
  facet_wrap(~DEPTH, ncol = 2, scales = "fixed") +
  theme_minimal()+
  theme(
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank()  # Remove strip background
  ) +
  scale_x_reverse()
#ggsave("output/Figure5'.png")
```

```{r Clean multifunctionality dataframe}
clean_multifunc <- asduffy %>%
  dplyr::select(pc1, ID, TRAT2, DEPTH, meanFunction, thresholds, nFunc, funcMaxed, mf_eff_1)

clean_multifunc %>%
  group_by(TRAT2, DEPTH) %>% 
  summarise(mean = mean(mf_eff_1),
            sd = sd(mf_eff_1))
```

For this analysis, we ran five competing models: 1. no effects (null model), 2. effects of TRAT2, 3. effects of depth, 4. effects of both TRAT2 and depth, but without interaction effects and 5. effects of both TRAT2 and depth, including their interaction. We then compared these models based on AIC values and selected the model with the lowest AIC.

```{r Explanatory models for Multifunctionality}
lm.multifunc1 <- lm(mf_eff_1~1, asduffy)
lm.multifunc2 <- lm(mf_eff_1~TRAT2, asduffy)
lm.multifunc3 <- lm(mf_eff_1~DEPTH, asduffy)
lm.multifunc4 <- lm(mf_eff_1~TRAT2*DEPTH, asduffy_func)
lm.multifunc5 <- lm(mf_eff_1~TRAT2+DEPTH, asduffy)
lm.multifunc6 <- lm(mf_eff_1~pc1+DEPTH, asduffy)

AIC(lm.multifunc1, lm.multifunc2, lm.multifunc3, lm.multifunc4, lm.multifunc5, lm.multifunc6)
summary(lm.multifunc4)

anova(lm.multifunc4)

Tuckeys<- TukeyHSD(lm.multifunc4)
print(Tuckeys)

cld <- multcompLetters4(lm.multifunc4, Tuckeys)
print(cld) 
```

```{r RandomForest}
#write.csv(asduffy[, c(29:52, 59)], "output/RF_indicators.csv")
RF_indicators <- asduffy[, c(29:52, 59)]
str(RF_indicators)
#write.csv(asduffy_func[, c(11:16, 23)], "output/RF_functions.csv")
RF_functions <- asduffy_func[, c(11:16, 23)]

summary(RF_indicators$mf_eff_1)
names(RF_indicators)

data <- RF_indicators
# entrenamos modelo
RFfit<- randomForest(mf_eff_1 ~ ., data=data, ntree=300, importance=T) # necesario importance=T para guardar el valor de las importancias
#IFd es la variable objeto, tu debes de poner el nombre de tu variable objeto

# Para asegurarnos de que se estabilizó el error
# Representa el error en vez de R2. si no se estabiliza el error igual hay que aumentar el numero de arboles, suele ser 500
plot(RFfit)


# Determinar la importancia de las variables
png("RFfit_plot.png", width = 800, height = 600)
varImpPlot(RFfit)
dev.off()
#incMSE indica el error por permutacion
#incNodePurity indica la capacidad de esa variable para separar nodos

# Cargar funcion Uniqueness_Imp_Function, este script debe estar guardado en la carpeta de trabajo
source("Uniqueness_Imp_Function.R")

# se aplica a data (indicar la posición de la variable objetivo, en este caso es la primera columna)
uniqueness_imp(data, target_column_position = 25, ntree = 300)
```

```{r Vertical distribution of soil}
#Calculation of the difference among depths
depth_dif <- dataset %>%
  dplyr::select(SITE, TRAT2, DEPTH, all_of(resp_variables)) %>%
  group_by(SITE,TRAT2) %>%
  dplyr::summarize(across(all_of(resp_variables), 
                   ~ mean(.[DEPTH == "topsoil"]) - mean(.[DEPTH == "subsoil"]),
                   .names = "{.col}_difference"))

depth_dif_sum <- depth_dif %>%
  group_by(TRAT2) %>%
  summarize(across(ends_with("_difference"), list(mean = mean, se = se)))
#write.csv(depth_dif_sum, "output/vertical_differences.csv")

# 3) Reshape the data from wide to long format to plot it
depth_long <- depth_dif_sum %>%
  pivot_longer(cols = ends_with("_mean"),
               names_to = "variables", 
               values_to = "Mean") %>%
  dplyr::select(TRAT2, variables, Mean)
  
depth_long_se <- depth_dif_sum %>%
  pivot_longer(cols = ends_with("_se"),
               names_to = "SE_function", 
               values_to = "SE") %>%
  dplyr::select(TRAT2, SE)

## Add the SE to the dataframe
depth_long$SE <- depth_long_se$SE

##### Visualization 
depth_long_filtered <- depth_long %>%
  filter(variables %in% c("pH_difference_mean", "EC_difference_mean",
                          "A_phosphorus_ppm_105_difference_mean", 
                          "NO3_mgL_105_difference_mean",
                          "Phosphatase_activity_µmol_g_h_difference_mean",
                          "Ergosterol_µg_g_difference_mean",
                          "Nematode_g_105_difference_mean",
                          "SOM_per_corregido_difference_mean",
                          "Ctotal_g_100g_105_difference_mean",
                          "Bulk_density_g_cm3_difference_mean"))

depth_long_filtered$variables <- factor(depth_long_filtered$variables, 
                           levels = c("pH_difference_mean",
                                      "A_phosphorus_ppm_105_difference_mean",
                                      "EC_difference_mean", "NO3_mgL_105_difference_mean",
                                      "Ergosterol_µg_g_difference_mean",
                                      "Nematode_g_105_difference_mean",
                                      "SOM_per_corregido_difference_mean",
                                      "Ctotal_g_100g_105_difference_mean",
                                      "Phosphatase_activity_µmol_g_h_difference_mean",
                                      "Bulk_density_g_cm3_difference_mean"))
depth_long_filtered$TRAT2 <- ordered(depth_long_filtered$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

#Plot (Figure 6)
ggplot(depth_long_filtered, aes(x = TRAT2, y = Mean, fill = TRAT2)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", alpha = 0.7) +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), position = position_dodge(0.9), width = 0.25) +
  scale_fill_manual(values = cols) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank(),
    legend.position = "none"
  ) +
  facet_wrap(~ variables, ncol = 2, scales="free_y")
#ggsave("output/Figure6.png", height = 7, width = 6.5, dpi = 300)

##### Linear models
var_dif <- depth_dif$pH_difference

lm_f <- aov(var_dif ~ TRAT2, data = depth_dif)
summary(lm_f)
anova(lm_f)
Tuckeys<- TukeyHSD(lm_f)
print(Tuckeys)

cld <- multcompLetters4(lm_f, Tuckeys)
print(cld) 
```

*SUPPLEMENTARY INFORMATION*

```{r Visualization of variables}
# We only want to plot the significative ones:
sig_vars <- names(dataset) %>% 
  intersect(c("SOM_per_corregido", 
                                       "Ctotal_g_100g_105",
                                       "NH4_mgL_105",
                                       "A_phosphorus_ppm_105",
                                       "MBC_mg_kg_105", 
                                       "Phosphatase_activity_µmol_g_h",
                                       "Nematode_g_105",
                                       "Ergosterol_µg_g",
                                       "pH", "EC",
              "Al_g_kg", "Fe_g_Kg"))

dataset$TRAT2 <- ordered(dataset$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

dataset %>%
  mutate(ID=row_number()) %>%
  dplyr::select(TRAT2, DEPTH, all_of(sig_vars)) %>%
  pivot_longer(all_of(sig_vars)) %>%
  #now a plot
  ggplot(aes(x = TRAT2, y = value, fill=DEPTH,
             color = TRAT2)) +
  stat_summary(shape=21, size=0.7, fun.data = mean_se) +
  stat_smooth(method = "lm", color = "black") +
  facet_wrap(vars(forcats::fct_relevel(name, "SOM_per_corregido", 
                                       "Ctotal_g_100g_105",
                                       "NH4_mgL_105",
                                       "A_phosphorus_ppm_105",
                                       "MBC_mg_kg_105", 
                                       "Phosphatase_activity_µmol_g_h",
                                       "Nematode_g_105",
                                       "Ergosterol_µg_g",
                                       "pH", "EC",
                                       "Al_g_kg", "Fe_g_Kg")), 
             scale = "free", strip.position = "left", ncol=2)+

  scale_color_manual(values= cols) +
  scale_fill_manual(values = c("topsoil" = cols, "subsoil" = "white")) +  
  labs(y = " ", x = "") +
  theme(legend.position = "none")+
  theme_minimal()+
  theme(
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank(),
    legend.position = "none"
  )
#ggsave("output/FigureS1.png", width = 5, height = 6.5, dpi = 300)
```

```{r Multifunctionality: using the raw dataset}
# With this approach we can see how the best performance is achieved by those plots with more functions reaching their maximum

#This function iterates over all functions and standardizes them between 0 and 1. Then it creates an averaged multifunctionality index 
#by averaging over all standardized functions
raw_standardized_df <- Firefungi_simple %>%
  cbind(getStdAndMeanFunctions(Firefungi_simple, selected_vars)) 

#Here we account for the number of functions that go over the 0.8 threshold
raw_standardized_df <-raw_standardized_df %>%
  getFuncsMaxed(selected_vars,
                threshmin=0.8, threshmax=0.8)

selected_vars.std <- paste0(selected_vars, ".std")

#Now effective number of functions
Firefungi_mult <- raw_standardized_df %>%
  mutate(n_eff_func_1 = multifunc::eff_num_func(., selected_vars.std, q = 1),
         n_eff_func_2 = multifunc::eff_num_func(., selected_vars.std, q = 2),
         
         mf_eff_1 = n_eff_func_1 * meanFunction,
         mf_eff_2 = n_eff_func_2 * meanFunction)

#Visualization of multifunctionality
Firefungi_mult$TRAT2 <- ordered(Firefungi_mult$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
Firefungi_mult$DEPTH <- ordered(Firefungi_mult$DEPTH, levels=c("topsoil", "subsoil"))
Firefungi_mult %>%
  dplyr::select(TRAT2, DEPTH, 
                mf_eff_1) %>%
 
  #now a plot
  ggplot(aes(x = TRAT2, y = mf_eff_1,
             color = TRAT2)) +
  stat_summary(fun.data = mean_se) +
  stat_smooth(method = "lm", color = "black") +
  facet_wrap(~DEPTH) +
  scale_color_manual(values = cols_3) +
  labs(y = "Effective Multifunctionality", x="",
       color = "Fire Severity") +
  theme_bw()
#ggsave("mult_raw_dataset.png")
```

```{r Multifunctionality: Grouping in Ecosystem functions as in Lucas-Borja et al. 2021 (same as Maestre 2012)}
Lucas_broja_norm <- Firefungi_simple %>%
  group_by(TRAT2, DEPTH) %>%
  mutate(Support = mean(c(pH, EC)),
         Nutrient_cycling = mean(c(A_phosphorus_ppm_105,NH4_mgL_seco_105, NO3_mgL_seco_105, Ntotal_g_kg, Ca_g_kg, K_g_kg, Mg_g_kg, Na_g_kg)),
         Climate_reg = mean(c(Ctotal_g_kg, Organic_matter_percent_corregido)),
         Waste_decomp = mean(c(Phosphatase_activity_µmol_g_h, Cmicrob_mg_kg_SECO_105)),
         Soil_health = mean(c(Nematode_gr_seco_105, Ergosterol_µg_g))) %>%
  ungroup()

ecosystem_functions <- Lucas_broja_norm %>%
  dplyr::select(TRAT2, DEPTH, Support, Nutrient_cycling, Climate_reg, Waste_decomp, Soil_health)

EF <- names(ecosystem_functions) %>% 
  intersect(c("Support", "Nutrient_cycling", "Climate_reg", "Waste_decomp", "Soil_health"))

ecosystem_functions <- ecosystem_functions %>%
  mutate(across(all_of(EF), 
                ~ rescale(., to=c(0,1)),
                .names = "{.col}_normalized"))

ecosystem_functions <- ecosystem_functions %>%
  mutate(across(all_of(paste0(EF, "_normalized")), 
                ~ (.-mean(.))/sd(.),
                .names = "{.col}_zscore"))

EF <- names(ecosystem_functions) %>% 
  intersect(c("Support_normalized_zscore", "Nutrient_cycling_normalized_zscore", "Climate_reg_normalized_zscore", "Waste_decomp_normalized_zscore", "Soil_health_normalized_zscore"))

#Plot
ecosystem_functions %>%
  dplyr::select(TRAT2, DEPTH, all_of(EF)) %>%
  pivot_longer(all_of(EF), names_to = "Variable", values_to = "Value") %>%
  ggplot(aes(x = TRAT2, y = Value, fill = DEPTH)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Mean Values by TRAT2 and DEPTH",
       x = "TRAT2",
       y = "Mean Value") +
  facet_wrap(~ Variable, scales = "free_y", ncol = 2) +
  theme_bw()

#######################
ecosystem_functions %>%                              
  group_by(TRAT2) %>% 
  summarize(min = min(Soil_health_normalized_zscore),
            median = median(Soil_health_normalized_zscore),
            mean = mean(Soil_health_normalized_zscore),
            max = max(Soil_health_normalized_zscore), 
            sv = sd(Soil_health_normalized_zscore),
            se = sd(Soil_health_normalized_zscore) / sqrt(n()),  
           )
```

```{r Deviation of values from UB mean}
# Mean and sd UB values for each var and depth 
result_df <- Firefungi_simple %>%
  filter(TRAT2 == "UB") %>%
  group_by(DEPTH) %>%
  summarise(across(all_of(selected_vars), list(mean = mean, sd = sd), .names = "{.col}_{fn}_UB"))

# Standard Deviation UB values for each var and depth
sd <- Firefungi_simple %>%
  filter(TRAT2 == "UB") %>%
  group_by(DEPTH) %>%
  summarise(across(all_of(selected_vars), sd, .names = "{.col}_sd_UB"))

#Left join with the whole dataset
df <- Firefungi_simple %>%
  left_join(result_df, by = "DEPTH") 

selected_vars <- names(df) %>% 
  intersect(c("pH", "EC", "Bulk_density_g_cm3", "A_phosphorus_ppm_105", "Phosphatase_activity_µmol_g_h", "NH4_mgL_105",
              "NO3_mgL_105", "Ergosterol_µg_g", "Ntotal_g_100g_105", "Ctotal_g_100g_105", "Carbon_stock_t_ha",
              "SOM_per_corregido", "MBC_mg_kg_105", "Nematode_g_105", "Ca_g_kg", "K_g_kg",
              "Mg_g_kg", "Na_g_kg", "Al_g_kg", "Fe_g_Kg","Zn_mg_Kg_105", "Cu_mg_Kg_105"))

#Mean deviation = (variable value - UB_mean value / UB_sd value)
df_c <- df %>%
  mutate(across(all_of(selected_vars), 
                ~ (. - get(paste0(cur_column(), "_mean_UB"))) / get(paste0(cur_column(), "_sd_UB")), 
                .names = "{.col}_deviation"))

deviations_df_c <- df_c %>%
  dplyr::select(ID, pc1, TRAT2, DEPTH, all_of(ends_with("_deviation")))


######################################################################################################################
############################################       STANDARDIZED SCORE     ############################################

deviations_df_c <- deviations_df_c %>%
  mutate(across(ends_with("_deviation"),            #This formula ensures that the further the absolute deviation from 0, 
                ~ rescale(.),             #the lower the standardized score, and the closer to 0, the higher the standardized score.
                .names = "{.col}_standardized")) 


df_standardized <- deviations_df_c %>%
  dplyr::select(TRAT2, DEPTH, all_of(ends_with("_standardized")))

######################################################################################################################

names(df_standardized) <- c("TRAT2", "DEPTH", "pH_stan", "EC_stan", "Bulk_stan", "Available_P_stan", "APA_stan", 
                                 "NH4_stan", "NO3_stan", "SOM_stan", "MBC_stan", "Nematodes_stan","Total_N_stan", 
                                 "Total_C_stan", "Carbon_stock_stan", "Al_stan", "Ca_stan", "Cu_stan", "K_stan", "Mg_stan",
                                 "Na_stan", "Zn_stan", "Fe_stan", "Ergosterol_stan")

selected_vars <- names(df_standardized) %>% 
  intersect(c("pH_stan", "EC_stan","Bulk_stan", "Available_P_stan", "APA_stan", 
                                 "NH4_stan", "NO3_stan", "SOM_stan", "MBC_stan", "Nematodes_stan","Total_N_stan", 
                                 "Total_C_stan", "Carbon_stock_stan", "Al_stan", "Ca_stan", "Cu_stan", "K_stan", "Mg_stan",
                                 "Na_stan", "Zn_stan", "Fe_stan", "Ergosterol_stan"))

######################################################################################################################
var_dev <- df_standardized$Bulk_stan
hist(var_dev)

lm_f <- aov(var_dev ~ TRAT2, data = df_standardized)
summary(lm_f)
anova(lm_f)
Tuckeys<- TukeyHSD(lm_f)
print(Tuckeys)

cld <- multcompLetters4(lm_f, Tuckeys)
print(cld) 
```

```{r Deviation of values from UB mean: visualization}
names(deviations_df_c) <- c("ID", "pc1","TRAT2", "DEPTH","pH", "EC", "Bulk density", "Available P", "APA", 
                                 "NH4", "NO3", "SOM", "MBC", "Nematodes","Total N", 
                                 "Total C", "Carbon stock", "Al", "Ca", "Cu", "K", "Mg",
                                 "Na", "Zn", "Fe", "Ergosterol")

selected_vars <- names(deviations_df_c) %>% 
  intersect(c( "pH", "EC", "Bulk density"))

deviations_df_c %>%
  dplyr::select(TRAT2, DEPTH, all_of(selected_vars)) %>%
  pivot_longer(all_of(selected_vars), names_to = "Indicators", values_to = "value") %>%
  ggplot(aes(x = value, y =  Indicators , fill = TRAT2)) +
  geom_violin(width=1, size=0.1, alpha=0.9) +
  #geom_point() +
  #geom_bar(stat="identity", position = "dodge") +
  #stat_summary(shape=21, size=0.7) +
  #coord_flip() +
  theme_ipsum() +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  scale_fill_manual(values = cols_3) +
  xlim(-2.5, 2.5)+
  theme_classic() 
#ggsave("deviations_Properties.png")
```

```{r Package and functions references}
sessionInfo()

citation("stats")
citation("factoextra")
citation("lme4")
citation("emmeans")
citation("scales")
citation("indicspecies")

```

