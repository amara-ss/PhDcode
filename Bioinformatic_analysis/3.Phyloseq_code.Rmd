---
title: "Phyloseq analysis of Navalacruz 2021 dataset sampling"
author: "Amara Santiesteban Serrano"
date: " r format(Sys.time(), '%d %B, %Y') "
output: 
  html_document:
    df_print: paged
    pdf_document: default
    word_document: default
  editor_options:
    chunk_output_type: inline
---

*Primero procesar las secuencias en DADA2 (1췈) y en LULU (2췈)*

```{r Packages}
#install.packages("pacman")
pacman::p_load("ggplot2","tidyr","dplyr","tidyverse","readxl","pastecs","lattice","forcats","corrgram","corrplot","HH","effects","car","multcompView","lme4", "devtools","emmeans","factoextra","ggfortify","RColorBrewer","MuMIn","scales","multifunc", "ggthemes", "knitr", "BiocManager", "phyloseq", "phangorn", "DECIPHER", "biomformat", "rbiom", "plyr", "indicspecies", "networkD3", "htmlwidgets", "webshot2", "vegan", "lme4", "car", "plyr", "ggpubr", "ggsignif", "ape", "cooccur", "igraph", "reshape2", "cowplot", "patchwork", "randomForest", "rfPermute", "ggtree", "FSA", "rcompanion", "phytools", "msa", "ggvegan", "VennDiagram")
```

```{r Packages: BiocManager}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("microbiome")
BiocManager::install(c("DECIPHER", "phangorn"))

remotes::install_github("gavinsimpson/ggvegan")
```

```{r Colors}
cols <- c("#41b6c4","#fd8d3c","#cb181d","#800026")
```

```{r data required}
#########################
#OTU abundance: *matrix*            class(clustered_asv_table)
#Taxonomy: *matrix*                 class(clustered_taxa)
#Metadata: *data.frame*
#FunGuild: *matrix*
########################

#We need the taxa table and the curated asv table to have the same number of entries
#We need the meta_data and the curated asv table to have the exact same samples names

##### OTU: abundance
colnames(clustered_asv_table) <- sapply(colnames(clustered_asv_table), function(name) {
  parts <- strsplit(name, "-FIREFUNGI")[[1]]
  return(paste0(parts[1], "-FIREFUNGI"))
})
#clustered_asv_table[] <- lapply(clustered_asv_table, as.numeric)

#### TAX: Taxonomy
class(clustered_tax_table)
clustered_tax_table <- as.matrix(clustered_tax_table)

#### SAM: Metadata
meta_data <- as.data.frame(Firefungi_soil_dataset_2021)
rownames(meta_data) <- paste0(rownames(meta_data), "-FIREFUNGI")

#We want to add a gradient of severity (pc1)
plot_vars <- c("Slope_per","Organic_layer_mean_depth_cm", "Charred_organic_layer_mean_cm", "Green_per", "Brown_per", "Consumed_per", "Grass_per", "Old_litter_per", "New_litter_per", "Mineral_per", "Ash_per", "Stone_per")
pca_sev <- prcomp(meta_data[,plot_vars], scale=T)
pc1 <- pca_sev$x[,1] 
pc1 <- as.data.frame(pc1)
meta_data_pc1 <- meta_data %>%
  dplyr::mutate(pc1 = pc1$pc1)
rownames(meta_data_pc1) <- paste0(1:80, "-FIREFUNGI")
meta_data_pc1 <- meta_data_pc1 %>% 
  mutate(Fe_g_Kg = Fe_mg_Kg_105/1000,
         C_N_ratio = Ctotal_g_100g_105/Ntotal_g_100g_105)
```

Since we are working with a relatively small and conserved region (ITS1), there is limited phylogenetic signal, which often results in polytomies and unresolved branches in traditional phylogenetic trees. A more suitable approach in this case is to use a distance-based clustering method, such as *UPGMA*, which summarizes sequence similarity without assuming a detailed evolutionary model.

```{r UPGMA Tree}
treeUPGMA  <- upgma(dm)
plot(treeUPGMA, main="UPGMA")

fun <- function(x) upgma(dist.ml(x))
bs_upgma <- bootstrap.phyDat(phang.align,  fun)
plotBS(treeUPGMA, bs_upgma, main="UPGMA")
```

The *phyloseq package* is a tool to import, store, analyze, and graphically display complex phylogenetic sequencing data that has already been clustered into Operational Taxonomic Units (OTUs), especially when there is associated sample data, phylogenetic tree, and/or taxonomic assignment of the OTUs. This package leverages many of the tools available in R for ecology and phylogenetic analysis (vegan, ade4, ape, picante), while also using advanced/flexible graphic systems (ggplot2) to easily produce publication-quality graphics of complex phylogenetic data. 

```{r Phyloseq object}
ps <- phyloseq::phyloseq(otu_table(clustered_asv_table, taxa_are_rows=TRUE), 
                         sample_data(meta_data, sample_names(sample.names)),
                         tax_table(clustered_tax_table))
ps
```

Se recomienda hacer un gr치fico de dispersi칩n donde en el eje X est칠 el n칰mero de secuencias y en el eje Y el n칰mero de OTUs: si la relaci칩n es positiva, primero se deben estandarizar los datos por rarefacci칩n antes de proseguir. Si la relaci칩n no es significativa se puede trabajar con la misma matriz.

```{r}

```

```{r Quality analysis}
# Define prevalence of each taxa (in how many samples did each taxa appear at least once)
# Compute prevalence (number of samples where an OTU is present)
prevdf <- apply(X = otu_table(ps),
                MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
                FUN = function(x) sum(x > 0))

prevdf <- data.frame(Prevalence = prevdf, row.names = taxa_names(ps))

# Add total abundance and taxonomy information
prevdf <- data.frame(Prevalence = prevdf$Prevalence,
                     TotalAbundance = phyloseq::taxa_sums(ps),
                     as.data.frame(tax_table(ps)))

#With the following table we can see how well represented is each "Phylum" (or Kingdom, etc...)
dfprev <- plyr::ddply(prevdf, "Kingdom", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))})
```

```{r Visualization}
# Define prevalence threshold as 5% of total samples 
prevalenceThreshold = 0.05 * phyloseq::nsamples(ps1)
prevalenceThreshold

#This plot will help us to identify which taxa are more abundant and prevalent in the dataset.
ggplot(prevdf, aes(TotalAbundance, Prevalence, color = Phylum)) + 
  geom_hline(yintercept = prevalenceThreshold, alpha = 0.5, linetype = 2) + 
  geom_point(size = 2, alpha = 0.7) + 
  scale_y_log10() + 
  scale_x_log10() + 
  xlab("Total Abundance") + 
  facet_wrap(~Phylum) +
  theme(legend.position = "none")
#ggsave("prevalence.png")

#This will show us the distribution of read counts per sample:
sample_sum_df <- data.frame(sum = sample_sums(ps1))
ggplot(sample_sum_df, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "grey", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank()) 
```

```{r ps0}
# We make sure that we do not have OTUs that are not present in any of the samples:
ps0 <- phyloseq::prune_taxa(phyloseq::taxa_sums(ps) > 0, ps)
ps0
#We also did a filtering of ASV with less than 5 reads but the result is the same (probably due to LULU & postclustering)
```

```{r Filtering: unwanted taxa}
#Based on the results above, we could decide to filter some Phylum out (the ones with less representation). We can also get rid of the Kingdoms not corresponding to fungi:
#plot_bar(ps, fill = "Kingdom") + 
#geom_bar(aes(color=Kingdom, fill=Kingdom), stat="identity", position="stack")

ps1 = phyloseq::subset_taxa(ps, Kingdom=="k__Fungi")
ps1

#plot_bar(ps1, fill = "Kingdom") + 
#geom_bar(aes(color=Kingdom, fill=Kingdom), stat="identity", position="stack")
```

```{r Number of unique phyla and genera}
tax <- tax_table(ps1)
tax_df <- as.data.frame(tax)

# Count unique phyla
n_phyla <- length(unique(tax_df$Phylum[!is.na(tax_df$Phylum) & tax_df$Phylum != ""]))

# Count unique genera
n_genera <- length(unique(tax_df$Genus[!is.na(tax_df$Genus) & tax_df$Genus != ""]))

cat("Number of unique phyla:", n_phyla, "\n")
cat("Number of unique genera:", n_genera, "\n")
```

*ADVICE*: check some sequences (from the 'asv_OTU.fasta' generated in DADA2, they can be accessed through Notepad++) in BLAST: https://blast.ncbi.nlm.nih.gov/Blast.cgi# --> copy and paste the whole sequence in the Entry query sequence box, and click on 'BLAST' at the end. This is a double check to see if our reference database (UNITE in this case) has assigned correctly the taxons.

```{r Alpha Diversity}
# Observed = Richness: total number of OTU observed in a sample (it does not consider abundance or eveness)
# Chao1: non-parametric estimator of the minimum species richness. The number of species in a community, accounting for the number of rare species that are likely to be missed
# Shannon: It measures the diversity of a community by considering both species richness and evenness. Higher values indicate greater diversity, with more even distribution of species abundances.

alpha_fungi <- microbiome::alpha(ps1, index = c("observed", "diversity_shannon", "diversity_fisher")) #ps1: only for Fungi Kingdom

alpha_fungi <- alpha_fungi %>% 
  tibble::rownames_to_column(var = "SampleID")

metadata_df <- meta_data %>% 
  tibble::rownames_to_column(var = "SampleID")

alpha_fungi <- left_join(alpha_fungi, metadata_df, by = "SampleID")

### MEAN RICHNESS PER FIRE SEVERITY
richness_summary <- alpha_fungi %>%
  dplyr::group_by(DEPTH, TRAT2) %>%                
  dplyr::summarise(mean_richness = mean(observed, na.rm = TRUE),
                   SE_richness = sd(observed) / sqrt(n()))

loss_percent <- richness_summary %>%
  dplyr::filter(DEPTH == "topsoil") %>%
  dplyr::filter(TRAT2 %in% c("UB", "HS2")) %>%
  dplyr::summarise(
    perc_loss = (mean_richness[TRAT2 == "UB"] - mean_richness[TRAT2 == "HS2"]) / 
                 mean_richness[TRAT2 == "UB"] * 100
  )
```

```{r Alpha Diversity Models}
alpha_fungi$TRAT2 <- ordered(alpha_fungi$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))
alpha_fungi$DEPTH <- ordered(alpha_fungi$DEPTH, levels=c("topsoil", "subsoil"))

### Visually assessment of data
var <- (alpha_fungi$diversity_fisher)

hist(var) 

alpha_fungi %>%
  ggplot(aes(x=TRAT2, y=var, fill=DEPTH)) +
  geom_boxplot(outlier.color = "red",
    outlier.shape = 8) +
  scale_fill_brewer(palette="Dark2") +
  stat_summary(fun= mean, geom="point", shape=20, size=2, colour="black") + 
  facet_wrap(~ DEPTH, scales="free_x") 

#################### WHOLE ##################################
#### FIRST!! We define the Contrast table we want to work with
options(contrasts=c(factor="contr.sum", ordered="contr.poly"))
##############################################################
mixed.null_SITE <- lmer(var ~ (1|SITE), data = (alpha_fungi %>% dplyr::filter(DEPTH=="subsoil")))
mixed.null_PLOT <- lmer(var ~ (1|PLOT), data = (alpha_fungi %>% dplyr::filter(DEPTH=="subsoil")))
mixed.null_COMBI <- aov(var ~ (1|SITE*PLOT), data = (alpha_fungi %>% dplyr::filter(DEPTH=="subsoil")))
##############################################################
#We want to make sure which one should be the random factor
AIC(mixed.null_SITE, mixed.null_PLOT, mixed.null_COMBI)
##############################################################

mixed.var <- lmer(var ~ TRAT2*DEPTH + (1|SITE), data = alpha_fungi)  #SITE selected as random effect

par(mfrow=c(1,3))
qqnorm(resid(mixed.var)); qqline(resid(mixed.var))
hist(resid(mixed.var))
plot(fitted(mixed.var), resid(mixed.var)); abline(h=0)
par(mfrow=c(1,1))

car::Anova(mixed.var, test.statistic="F", type=3)

multcomp::cld(emmeans(mixed.var, ~TRAT2*DEPTH, type="response"), Letters= letters) #Tuckey's post-hoc test
```

*We've run Alpha Diversity with all ASV (ps) and with only Kingdom Fungi (ps1)*

-No significant differences found across *DEPTHS*
-No significant differences in *Shannon diversity* across treatments
-Significant differences found in *Observed and Chao1 richness*: 
  --> ps Observed and Chao1 richness (no sig. differences across DEPTHs; across treatmentsUB, UB > LS > HS1 > HS2)
  --> ps1 (k__Fungi): Observed and Chao1 richness (no sig. differences across DEPTHs; across treatments UB, LS > HS1, HS2)

```{r Alpha Diversity Plot}
p <- plot_richness(ps1, color = "TRAT2", x = "TRAT2", 
              measures = c("Observed", "Shannon", "Fisher")) 
p$layers <- p$layers[-1]
p+  geom_boxplot(aes(fill = TRAT2), alpha=.2) + 
  geom_jitter(width = 0.2, size = 2, alpha=.5) +  
  scale_color_manual(values = cols) + 
  scale_fill_manual(values = cols) +
  facet_grid(variable ~ DEPTH, scales="free") +
  theme(
    panel.grid = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid.minor = element_blank(),
    axis.line = element_line(),
    strip.background = element_blank(),  # Remove strip background
    axis.text.x = element_text(angle = 0.1, hjust = 1),  # Rotate x-axis labels
    panel.background = element_blank(),  # Remove panel background color
    plot.background = element_blank(),   # Remove plot background color
    #legend.position = "none" # Remove legend
  )
#ggsave("alpha_div_k_fungi.png")

alpha_fungi_plot <- alpha_fungi %>%
  dplyr::select(TRAT2, DEPTH, observed, diversity_shannon, diversity_fisher)
# Pivot longer
alpha_fungi_long <- alpha_fungi_plot %>%
  pivot_longer(
    cols = c(diversity_fisher, diversity_shannon, observed),
    names_to = "Index",
    values_to = "Value"
  )

alpha_fungi_long$TRAT2 <- factor(alpha_fungi_long$TRAT2, levels = c("UB", "LS", "HS1", "HS2") )
alpha_fungi_long$Index <- factor(alpha_fungi_long$Index, levels = c("observed", "diversity_shannon", "diversity_fisher") )
alpha_fungi_long$DEPTH <- factor(alpha_fungi_long$DEPTH, levels = c("topsoil","subsoil"))

ggplot(alpha_fungi_long, aes(x=TRAT2, y = Value, alpha=.6, color=TRAT2))+
  geom_boxplot(aes(fill = TRAT2), alpha=.2) + 
  geom_jitter(width = 0.2, size = 3, alpha=.3) + # puntos individuales
  scale_color_manual(values = cols) + 
  scale_fill_manual(values = cols) +
  theme_bw()+
  theme(
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(),
    strip.background = element_blank(),  # Remove strip background
    axis.text.x = element_text(angle = 0.1, hjust = 1),  # Rotate x-axis labels
    panel.background = element_blank(),  # Remove panel background color
    plot.background = element_blank(),   # Remove plot background color
    #legend.position = "none"             # Remove legend
  )+
  facet_grid(Index~DEPTH, scales="free_y")
#ggsave("alpha_div_k_fungi2.png")          #### FIGURE 3 ####
```

```{r Alpha Div/Phylum}
# Ascomycota
ps_asco <- phyloseq::subset_taxa(ps1, Phylum == "p__Ascomycota")
alpha_asco <- microbiome::alpha(ps_asco, index = c("observed", "diversity_shannon", "diversity_fisher"))

# Basidiomycota
ps_basi <- phyloseq::subset_taxa(ps1, Phylum == "p__Basidiomycota")
alpha_basi <- microbiome::alpha(ps_basi, index = c("observed", "diversity_shannon", "diversity_fisher"))

alpha_asco$Phylum <- "Ascomycota"
alpha_asco <- alpha_asco %>% 
  tibble::rownames_to_column(var = "SampleID")
alpha_asco <- left_join(alpha_asco, metadata_df, by = "SampleID")

alpha_basi$Phylum <- "Basidiomycota"
alpha_basi <- alpha_basi %>% 
  tibble::rownames_to_column(var = "SampleID")
alpha_basi <- left_join(alpha_basi, metadata_df, by = "SampleID")

alpha_by_phylum <- rbind(alpha_asco, alpha_basi)

alpha_phylum_plot <- alpha_by_phylum %>%
  dplyr::select(TRAT2, DEPTH, Phylum, observed, diversity_shannon, diversity_fisher)
# Pivot longer
alpha_phylum_long <- alpha_phylum_plot %>%
  pivot_longer(
    cols = c(diversity_fisher, diversity_shannon, observed),
    names_to = "Index",
    values_to = "Value"
  )

alpha_phylum_long$TRAT2 <- factor(alpha_phylum_long$TRAT2, levels = c("UB", "LS", "HS1", "HS2") )
alpha_phylum_long$Index <- factor(alpha_phylum_long$Index, levels = c("observed", "diversity_shannon", "diversity_fisher") )
alpha_phylum_long$DEPTH <- factor(alpha_phylum_long$DEPTH, levels = c("topsoil","subsoil"))

ggplot(alpha_phylum_long, aes(x=TRAT2, y = Value, shape = Phylum, alpha=.6, color=TRAT2))+
  geom_boxplot(aes(fill = TRAT2), alpha=.2) + 
  geom_jitter(width = 0.2, size = 3, alpha=.3) + 
  scale_color_manual(values = cols) + 
  scale_fill_manual(values = cols) +
  theme_bw()+
  theme(
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(),
    strip.background = element_blank(),  # Remove strip background
    axis.text.x = element_text(angle = 0.1, hjust = 1),  # Rotate x-axis labels
    panel.background = element_blank(),  # Remove panel background color
    plot.background = element_blank(),   # Remove plot background color
    #legend.position = "none"             # Remove legend
  )+
  facet_grid(Index~DEPTH, scales="free_y")
#ggsave("alpha_asco_basidio.png")

### MODELS: ARE THERE SIGNIFICANT DIFFERENCES IN ASCOMYCOTA (OR BASIDIOMYCOTA) ALPHA-DIVERSITY (e.g: Richness) ACROSS FIRE SEVERITIES AND SOIL DEPTHS?
alpha_by_phylum_TOP <- alpha_by_phylum %>% dplyr::filter(DEPTH=="topsoil")
alpha_by_phylum_SUB <- alpha_by_phylum %>% dplyr::filter(DEPTH=="subsoil")

lmm_asco <- lmer(diversity_fisher ~ TRAT2 + (1|SITE), data = alpha_by_phylum_SUB %>% filter(Phylum == "Ascomycota"))

par(mfrow=c(1,3))
qqnorm(resid(lmm_asco)); qqline(resid(lmm_asco))
hist(resid(lmm_asco))
plot(fitted(lmm_asco), resid(lmm_asco)); abline(h=0)
par(mfrow=c(1,1))

car::Anova(lmm_asco, test.statistic="F", type=3)

multcomp::cld(emmeans(lmm_asco, ~TRAT2, type="response"), Letters= letters) #Tuckey's post-hoc test

### MEAN RICHNESS PER FIRE SEVERITY
richness_summary <- alpha_by_phylum %>%
  dplyr::group_by(DEPTH, Phylum, TRAT2) %>%                
  dplyr::summarise(mean_richness = mean(observed, na.rm = TRUE),
                   SE_richness = sd(observed) / sqrt(n()))
```

```{r Agglomerate by taxonomic ranks}
# This step is necessary when we work with taxonomic ranks above ASV
# Phylum -> For example, in this case we need 2 numbers per sample (UB_TOPSOIL_1: one number for Ascomycota and one for Basidio)
ps1_phylum <- tax_glom(ps1, taxrank = "Phylum")
sample_data(ps1_phylum)
tax_table(ps1_phylum)
ps1_phylum_melted <- psmelt(ps1_phylum)
# Phylum TOPSOIL
ps1_phylum_topsoil <- subset_samples(ps1_phylum, DEPTH == "topsoil")
ps1_phylum_topsoil <- filter_taxa(ps1_phylum_topsoil, function(x) sum(x) > 0, prune = TRUE)
# Phylum SUBSOIL
ps1_phylum_subsoil <- subset_samples(ps1_phylum, DEPTH == "subsoil")
ps1_phylum_subsoil <- filter_taxa(ps1_phylum_subsoil, function(x) sum(x) > 0, prune = TRUE)

# Class
ps1_class <- tax_glom(ps1, taxrank = "Class")
sample_data(ps1_class)
tax_table(ps1_class)
ps1_class_melted <- psmelt(ps1_class)

# Order
ps1_order <- tax_glom(ps1, taxrank = "Order")
sample_data(ps1_order)
tax_table(ps1_order)
ps1_order_melted <- psmelt(ps1_order)

# Family
ps1_family <- tax_glom(ps1, taxrank = "Family")
sample_data(ps1_family)
tax_table(ps1_family)
ps1_family_melted <- psmelt(ps1_family)
# Family TOPSOIL
ps1_family_topsoil <- subset_samples(ps1_family, DEPTH == "topsoil")
ps1_family_topsoil <- filter_taxa(ps1_family_topsoil, function(x) sum(x) > 0, prune = TRUE) # filter absent taxa
# Family SUBSOIL
ps1_family_subsoil <- subset_samples(ps1_family, DEPTH == "subsoil")
ps1_family_subsoil <- filter_taxa(ps1_family_subsoil, function(x) sum(x) > 0, prune = TRUE)

# Genus
tax_table(ps1)
ps1_genus <- tax_glom(ps1, taxrank = "Genus")
sample_data(ps1_genus)
tax_table(ps1_genus)
ps1_genus_melted <- psmelt(ps1_genus)
# Genus TOPSOIL
ps1_genus_topsoil <- subset_samples(ps1_genus, DEPTH == "topsoil")
ps1_genus_topsoil <- filter_taxa(ps1_genus_topsoil, function(x) sum(x) > 0, prune = TRUE) # filter absent taxa
# Genus SUBSOIL
ps1_genus_subsoil <- subset_samples(ps1_genus, DEPTH == "subsoil")
ps1_genus_subsoil <- filter_taxa(ps1_genus_subsoil, function(x) sum(x) > 0, prune = TRUE)
```

```{r Stacked barplot of diversity at phylum level}
ps1_phylum_rel <- transform_sample_counts(ps1_phylum, function(x) x / sum(x))
# Convert wide format to long format
df_phylum <- psmelt(ps1_phylum_rel)  

# SINCE WE HAVE AGGREGATED THE PHYLOSEQ OBJECT BY PHYLUM --> ABUNDANCE = PHYLUM ABUNDANCE/SAMPLE
 
# Mean abundance per Phylum
phylum_mean_abund <- df_phylum %>%
  dplyr::group_by(Phylum, TRAT2, DEPTH) %>%
  dplyr::summarise(
    mean_abundance = mean(Abundance),
    se_abundance = sd(Abundance) / sqrt(n()))

# Global abundance per phylum
df_global_percent <- df_phylum %>%
  dplyr::group_by(Phylum) %>%
  dplyr::summarise(GlobalAbundance = mean(Abundance)) %>%
  dplyr::mutate(Percentage = GlobalAbundance / sum(GlobalAbundance) * 100) %>%
  arrange(desc(Percentage))

# Percentages
df_percent <- df_phylum %>%
  dplyr::group_by(TRAT2, DEPTH, Phylum) %>%
  dplyr::summarise(Abundance = mean(Abundance)) %>%
  ungroup() %>%
  dplyr::group_by(TRAT2, DEPTH) %>%
  dplyr::mutate(Percentage = Abundance * 100,
         pos = cumsum(Abundance) - 0.5 * Abundance) # This is only to center the text

df_phylum$TRAT2 <- ordered(df_phylum$TRAT2,
                              levels = c("UB", "LS", "HS1", "HS2")) 
my_palette <- c(
  
  "#8DD3C7", # turquesa
  "#7570B3", # p칰rpura
  "#B3DE69", # verde lima
  "#BC80BD", # lavanda
  "#66A61E", # verde oliva
  "#E6AB02" # mostaza
 
)

df_percent2 <- df_percent %>%
  dplyr::mutate(Phylum = fct_lump(as.factor(Phylum), prop = 0.02, other_level = "Other"))

df_percent2$Phylum <- ordered(df_percent$Phylum, levels = c("p__Ascomycota", "p__Basidiomycota", "p__Mortierellomycota", "Other"))

ggplot(df_percent2, aes(x = TRAT2, y = Abundance, fill = Phylum)) +
  geom_bar(stat = "identity", position = "stack") +
  #geom_text(aes(y = pos, label = ifelse(Percentage > 5, paste0(round(Percentage), "%"), "")),
  #          color = "white", size = 3) +
  scale_fill_manual(values = my_palette) +
  coord_flip() +  
  labs(x = "Fire Severity", y = "Relative abundance", fill = "Phylum") +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(),
    strip.background = element_blank(),  # Remove strip background
    axis.text.x = element_text(angle = 0.1, hjust = 1),  # Rotate x-axis labels
    panel.background = element_blank(),  # Remove panel background color
    plot.background = element_blank(),   # Remove plot background color
    legend.position = "none"             # Remove legend
  )+
  #scale_fill_manual(values= okabe_ito_10) +
  #scale_fill_viridis_d(option = "viridis", alpha = 0.6)+
  facet_wrap(~DEPTH)
#ggsave("stacked_phylum3.png") #### FIGURE 2 ####
```

```{r Phylum Models}
# Fit a Linear Mixed-Effects Model
# Here, random effect is Sample (or any grouping variable) and fixed effects are Phylum, DEPTH, and TRAT2

lmm_results <- lmer(Abundance ~ Phylum * DEPTH * TRAT2 + (1|Sample), data = df_phylum) #(1|Sample) since each sample has various Phyla

par(mfrow=c(1,3))
qqnorm(resid(lmm_results)); qqline(resid(lmm_results))
hist(resid(lmm_results))
plot(fitted(lmm_results), resid(lmm_results)); abline(h=0)
par(mfrow=c(1,1))

car::Anova(lmm_results, test.statistic="F", type=3)

multcomp::cld(emmeans(lmm_results, ~TRAT2*DEPTH, type="response"), Letters=letters) #Tuckey's post-hoc test

#NO SIGNIFICANT DIFFERENCES AMONG FIRE SEVERITIES OR DEPTHS FOR GLOBAL  PHYLUM COMPOSTITION --> However, with this approach it is impossible to know the weight of specific Phylum variations. 

#Linear models for each phylum: 
df_phylum_TOP <- df_phylum %>% dplyr::filter(DEPTH=="topsoil")
df_phylum_SUB <- df_phylum %>% dplyr::filter(DEPTH=="subsoil")

lm_specific <- lm(Abundance ~ TRAT2, data = df_phylum_SUB %>% filter(Phylum == "p__Basidiobolomycota"))
anova(lm_specific)
emm <- emmeans(lm_specific, pairwise ~ TRAT2)

cld_results <- cld(emm$emmeans, Letters = letters)
cld_results
```

```{r Most abundant 6 Order}
order.sum = tapply(phyloseq::taxa_sums(ps1_order), 
                   tax_table(ps1_order)[, "Order"], 
                   sum, na.rm=TRUE)
top6order = names(sort(order.sum, TRUE))[1:6]
psTOP_order = phyloseq::prune_taxa((tax_table(ps1_order)[, "Order"] %in% top6order), ps1_order)
psTOP_order

plot_bar(psTOP_order, "Order", fill = "Order", facet_grid = ~TRAT2) 

df_bar <- psmelt(psTOP_order)
summary_df <- df_bar %>%
    dplyr::group_by(Order, TRAT2, DEPTH) %>%
    dplyr::summarise(
    mean_abundance = mean(Abundance),
    sum_abundance = sum(Abundance),
    se_abundance = sd(Abundance) / sqrt(n()))

# fix order of factors
summary_df$TRAT2 <- factor(summary_df$TRAT2, levels = c("UB", "LS", "HS1", "HS2"))
summary_df$DEPTH <- factor(summary_df$DEPTH, levels = c("topsoil", "subsoil"))

# Color palette (10 orders)
cols6 <- RColorBrewer::brewer.pal(6, "Paired")

# Barplot
ggplot(summary_df, aes(x = Order, y = mean_abundance, fill = Order)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = mean_abundance - se_abundance,
                    ymax = mean_abundance + se_abundance),
                    width = 0.2, position = position_dodge(0.9)) +
  facet_grid(DEPTH ~ TRAT2) +
  scale_fill_manual(values = cols6) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.x = element_blank(),
    strip.text = element_text(size = 12),
    #legend.position = "none"
  ) 
#ggsave("top6orders.png")
```

```{r Species co-ocurrence: Order}
tax_mat <- as.data.frame(tax_table(ps1_order))
otu_mat <- as.data.frame(otu_table(ps1_order)) 

# Create a named vector: names = ASV IDs, values = Orders
asv_to_order <- tax_mat$Order
names(asv_to_order) <- rownames(tax_mat)

# Convert abundance data to presence/absence (1 if >0, else 0)
asv_pa <- ifelse(otu_mat > 0, 1, 0)
asv_pa_order <- asv_pa
rownames(asv_pa_order) <- asv_to_order[rownames(asv_pa)]  # rename rows

cooccur_result <- cooccur(asv_pa_order, type = "spp_site",
                          thresh = TRUE, spp_names = TRUE)

#png("cooccurrence_plot.png", width = 800, height = 800) 
par(mfrow=c(2,1))
plot(cooccur_result)
#dev.off()

plot.cooccur(cooccur_result)
```

```{r Most abundant 10 Genus}
order.sum = tapply(phyloseq::taxa_sums(ps1_genus), 
                   tax_table(ps1_genus)[, "Genus"], 
                   sum, na.rm=TRUE)
top10genus = names(sort(order.sum, TRUE))[1:10]
psTOP_genus = phyloseq::prune_taxa((tax_table(ps1_genus)[, "Genus"] %in% top10genus), ps1_genus)
psTOP_genus

plot_bar(psTOP_genus, "Genus", fill = "Genus", facet_grid = ~TRAT2) 

df_bar <- psmelt(psTOP_genus)
summary_df <- df_bar %>%
    dplyr::group_by(Genus, TRAT2, DEPTH) %>%
    dplyr::summarise(
    mean_abundance = mean(Abundance),
    sum_abundance = sum(Abundance),
    se_abundance = sd(Abundance) / sqrt(n()))

# fix order of factors
summary_df$TRAT2 <- factor(summary_df$TRAT2, levels = c("UB", "LS", "HS1", "HS2"))
summary_df$DEPTH <- factor(summary_df$DEPTH, levels = c("topsoil", "subsoil"))

# Color palette (10 orders)
cols10 <- RColorBrewer::brewer.pal(10, "Paired")

# Barplot
ggplot(summary_df, aes(x = Genus, y = mean_abundance, fill = Genus)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = mean_abundance - se_abundance,
                    ymax = mean_abundance + se_abundance),
                    width = 0.2, position = position_dodge(0.9)) +
  facet_grid(DEPTH ~ TRAT2) +
  scale_fill_manual(values = cols10) +
  theme_bw() +
  theme(
    #panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.x = element_blank(),
    strip.text = element_text(size = 12),
    #legend.position = "none"
  ) 
#ggsave("top10genus.png")
```

Plot.cooccur function available at: https://github.com/griffithdan/cooccur/blob/master/R/plot.cooccur.R

```{r Species co-ocurrence: Genus}
tax_mat <- as.data.frame(tax_table(ps1_genus))
otu_mat <- as.data.frame(otu_table(ps1_genus)) 

# Create a named vector: names = ASV IDs, values = Orders
asv_to_order <- tax_mat$Genus
names(asv_to_order) <- rownames(tax_mat)

# Convert abundance data to presence/absence (1 if >0, else 0)
asv_pa <- ifelse(otu_mat > 0, 1, 0)
asv_pa_order <- asv_pa
rownames(asv_pa_order) <- asv_to_order[rownames(asv_pa)]  # rename rows

cooccur_result <- cooccur(asv_pa_order, type = "spp_site",
                          thresh = TRUE, spp_names = TRUE)

#png("cooccurrence_plot.png", width = 800, height = 800) 
par(mfrow=c(2,1))
plot(cooccur_result)
#dev.off()
```

```{r Buubles top 10 Order}
ggplot(df_bar, aes(x= TRAT2, y=Order, size = Abundance, color=TRAT2)) +
  geom_point()+
  scale_size(range = c(.1, 15)) +
  scale_color_manual(values = cols) +
theme(
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank(),
    legend.position = "none" # Remove strip background
  ) +
  facet_wrap(~DEPTH)
#ggsave("Bubbles_top10phyla.png")
```

*Beta diversity* is going to account for the *turnover* across sites, treatments...
It is based on distances --> we work with the *Hellinger transformed data*
*Bray-Curtis* dissimilarity is indicated for ABUNDANCE data 

```{r Hellinger transformation}
# It is designed to transform count data or relative abundance data in a way that reduces the influence of large values and makes the data more suitable for techniques like Principal Component Analysis (PCA) or cluster analysis. The transformation helps in emphasizing the relative differences between samples.
# It consist in 1) convert count data to proportions and 2) apply a square root transformation of 
# It preserves EUCLIDEAN DISTANCES --> perfect for Beta-diversity and other analysis

#Create a new phyloseq object:
ps_hel <- ps1
# Extract the OTU table
otu_table_ps <- otu_table(ps_hel)
taxa_rows <- taxa_are_rows(ps_hel)

# Perform Hellinger transformation
hellinger_otu_table <- vegan::decostand(as(otu_table_ps, "matrix"), method = "hellinger")
# Replace the OTU table in the phyloseq object
otu_table(ps_hel) <- otu_table(hellinger_otu_table, taxa_are_rows = taxa_rows)
```

```{r Beta diversity}
dist_hel <- vegdist(hellinger_otu_table, method="bray")
#heatmap(as.matrix(dist_hel))

#Plot of the different ordination methods
GP.ord <- ordinate(ps_hel, "NMDS", "bray")
p1 = plot_ordination(ps_hel, GP.ord, type="taxa", color="Phylum", title="taxa")
print(p1)

p1 + facet_wrap(~Phylum, 3)

p2 = plot_ordination(ps_hel, GP.ord, type="TRAT2", color="TRAT2", shape="DEPTH") 
p2 + geom_polygon(aes(fill=TRAT2)) + geom_point(size=5) + ggtitle("samples")

### Loop through different method parameter options to the plot_ordination function and store the plot results in a list. This code chunk performs each ordination method, creates the corresponding graphic based on the first two axes of each ordination result, and then stores each ggplot2 plot object in a different named element of the list named plist:
dist = "bray"
ord_meths = c("CCA", "RDA", "NMDS", "MDS", "PCoA")
plist = llply(as.list(ord_meths), function(i, physeq, dist){
        ordi = ordinate(physeq, method=i, distance=dist)
        plot_ordination(physeq, ordi, "samples", color="TRAT2")
}, ps_hel, dist)

names(plist) <- ord_meths

### The following chunk will extract the data from each of those individual plots, and put it back together in one big data.frame suitable for including all plots in one graphic:
pdataframe = plyr::ldply(plist, function(x){
    df = x$data[, 1:2]
    colnames(df) = c("Axis_1", "Axis_2")
    return(cbind(df, x$data))
})
names(pdataframe)[1] = "method"

p = ggplot(pdataframe, aes(Axis_1, Axis_2, color=TRAT2, shape=DEPTH, fill=TRAT2, alpha=.3))
p = p + geom_point(size=4) + geom_polygon()
p = p + facet_wrap(~method, scales="free")
p = p + scale_fill_manual(values=cols)
p = p + scale_colour_manual(values=cols)
p
#ggsave("ordination_methods_ps1.png", plot = p, width = 12, height = 10, dpi = 300, bg = "white")
```

*PCoA (Principal Coordinate Analysis)*
- A linear metric ordination technique.
- Distance preservation: Attempts to preserve actual distances (Euclidean-like) as much as possible.
-Assumes that the dissimilarity metric is a good approximation of true distances.
-The axes are ordered based on the amount of variation they explain.
-The distance between points is quantitative and can be directly interpreted.
-Best use case: When you assume a linear relationship between distances and the underlying data structure.
游릭 Advantages:
Provides a direct visualization of group differences.
The percentage of variance explained by each axis is meaningful.
游댮 Disadvantages:
Can be influenced by highly skewed data or non-Euclidean relationships.
Assumes a Euclidean-like structure, which is not always valid for ecological data.

```{r Principal Coordinate Analysis (PCoA)}
bray_dist <- phyloseq::distance(ps_hel, method="bray")
# Perform PCoA
pcoa_result <- cmdscale(bray_dist, k = 2, eig=TRUE)  # k = dimensions

# Create a data frame for the PCoA results
pcoa_df <- data.frame(
  PCoA1 = pcoa_result$points[, 1],
  PCoA2 = pcoa_result$points[, 2],
  Sample = rownames(pcoa_result$points)
)
ps_hel_meta_data <- ps_hel_meta_data %>%
  mutate(Sample = rownames(ps_hel_meta_data))

# Percent variance explained
eig_vals <- pcoa_result$eig
variance_explained <- eig_vals / sum(eig_vals) * 100
variance_explained[1:2]  # PCoA1 and PCoA2

# Merge with metadata
pcoa_df <- merge(pcoa_df, ps_hel_meta_data, by = "Sample")

#Add envfit
chem_vars <- c("pH", "EC", "densidad_revisada_25", "C_N_ratio",
              "A_phosphorus_ppm_105", "Phosphatase_activity_췃mol_g_h", 
              "NH4_mgL_105","NO3_mgL_105", 
              "Ntotal_g_100g_105", "Ctotal_g_100g_105", "Carbon_stock_Mg_ha",
              "Nitrogen_stock_Mg_ha", "SOM_per_corregido", "MBC_mg_kg_105",
              "Nematode_g_105", "Ca_g_kg", "K_g_kg","Mg_g_kg", "Na_g_kg", 
              "Al_g_kg", "Fe_g_Kg","Zn_mg_Kg_105", "Cu_mg_Kg_105")

env2_df <- ps_hel_meta_data %>%
  dplyr::select(all_of(chem_vars))

envfit_results  <- vegan::envfit(pcoa_result, env2_df, permutations = 999, na.rm = TRUE)

arrows_df <- as.data.frame(scores(envfit_results, display = "vectors"))
arrows_df$Variable <- rownames(arrows_df)
mult <- 1.5  # para ajustar la longitud de las flechas al gr치fico
arrows_df <- arrows_df %>%
  dplyr::mutate(PCoA1 = Dim1 * mult,
                PCoA2 = Dim2 * mult)

# Plot PCoA
pcoa_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, fill = TRAT2, shape = DEPTH)) +
  geom_point(aes(fill = TRAT2, size = DEPTH), shape = 21, color = "black", alpha = 0.6)+
  scale_fill_manual(values = cols) +   # relleno (fill) con tu paleta
  theme_classic(base_size = 14) +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    #panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    axis.text = element_text(size = 13, color = "black"),
    axis.title = element_text(size = 15, face = "bold"),
    legend.position = "right",
    legend.key = element_blank(),
    strip.background = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  )
#ggsave("PCoA2.png") #### FIGURE 4 ####

####TOPSOIL
ps_hel_topsoil <- subset_samples(ps_hel, DEPTH == "topsoil")
bray_dist_top <- phyloseq::distance(ps_hel_topsoil, method="bray")
# Perform PCoA

pcoa_top <- cmdscale(bray_dist_top, k = 2, eig=TRUE)  # k = dimensions
str(pcoa_top)
# Create a data frame for the PCoA results
pcoa_top_df <- data.frame(PCoA1 = pcoa_top[, 1],
                      PCoA2 = pcoa_top[, 2],
                      Sample = rownames(pcoa_top))
class(pcoa_top_df)

meta_data_top <- ps_hel_meta_data %>% dplyr::filter(DEPTH=="topsoil")
meta_data_top <- meta_data_top %>%
  mutate(Sample = rownames(meta_data_top))

# Percent variance explained
eig_vals <- pcoa_top$eig
variance_explained <- eig_vals / sum(eig_vals) * 100
variance_explained[1:2]  # PCoA1 and PCoA2

# Merge with metadata
pcoa_top_df_merged <- merge(pcoa_top_df, meta_data_top, by = "Sample")

# Add envfit:
env2_SUB <- ps_hel_meta_data %>%
  filter(DEPTH =="topsoil") %>%
  dplyr::select(all_of(chem_vars)) 

# Run envfit using the distance matrix and the environmental variables
envfit_top <- envfit(pcoa_top, env2_TOP, permutations = 999, na.rm = TRUE)

env_coord_top <- envfit_top$vectors$arrows
env_coord_sig_top <- as.data.frame(env_coord_top[envfit_top$vectors$pvals < 0.01, ])
env_coord_sig_top

env_coord_sig_top$Variable <- rownames(env_coord_sig_top)
mult <- 1.5  # para ajustar la longitud de las flechas al gr치fico
arrows_df <- env_coord_sig_top %>%
  dplyr::mutate(PCoA1 = Dim1 * mult,
                PCoA2 = Dim2 * mult)
pcoa_top_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, color = TRAT2)) +
  geom_segment(data = arrows_df,
               aes(x = 0, y = 0, xend = PCoA1*0.5, yend = PCoA2*0.5),
               arrow = arrow(length = unit(0.2, "cm")),
               size = 1, color = "grey",
               inherit.aes = FALSE) +
  geom_point(size = 5, alpha = .6) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  ) +
  scale_x_reverse()
#ggsave("PCoA_top.png")

# Plot PCoA
pcoa_top_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, color = TRAT2)) +
  geom_segment(data = arrows_df,
               aes(x = 0, y = 0, xend = PCoA1*0.5, yend = PCoA2*0.5), # xend and yend *0.5 to reduce arrow lenght
               arrow = arrow(length = unit(0.2, "cm")),
               size =1, color = "grey",
               inherit.aes = FALSE) +  
  geom_text(data = arrows_df,
            aes(x = PCoA1, y = PCoA2, label = Variable),
            size = 4, hjust = 0.5, vjust = -0.7,
            inherit.aes = FALSE) +  
  geom_point(size = 5, alpha=.6) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none") +
  scale_x_reverse()
#ggsave("PCoA_top.png")

####SUBSOIL
ps_hel_subsoil <- subset_samples(ps_hel, DEPTH == "subsoil")
bray_dist_sub <- phyloseq::distance(ps_hel_subsoil, method="bray")
# Perform PCoA
pcoa_sub <- cmdscale(bray_dist_sub, k = 2, eig=TRUE)  # k = dimensions
# Create a data frame for the PCoA results
pcoa_sub_df <- data.frame(PCoA1 = pcoa_sub[, 1],
                      PCoA2 = pcoa_sub[, 2],
                      Sample = rownames(pcoa_sub))
meta_data_sub <- meta_data_sub %>%
  mutate(Sample = rownames(meta_data_sub))

# Percent variance explained
eig_vals <- pcoa_sub$eig
variance_explained <- eig_vals / sum(eig_vals) * 100
variance_explained[1:2]  # PCoA1 and PCoA2

# Merge with metadata
pcoa_sub_df <- merge(pcoa_sub_df, meta_data_sub, by = "Sample")

# Add envfit:
env2_SUB <- ps_hel_meta_data %>%
  filter(DEPTH =="subsoil") %>%
  dplyr::select(all_of(chem_vars)) 

# Run envfit using the distance matrix and the environmental variables
envfit_sub <- envfit(pcoa_sub, env2_SUB, permutations = 999, na.rm = TRUE)

env_coord_sub <- envfit_sub$vectors$arrows
env_coord_sig_sub <- as.data.frame(env_coord_sub[envfit_sub$vectors$pvals < 0.01, ])
env_coord_sig_sub

env_coord_sig_sub$Variable <- rownames(env_coord_sig_sub)
mult <- 1.5  # para ajustar la longitud de las flechas al gr치fico
arrows_df <- env_coord_sig_sub %>%
  dplyr::mutate(PCoA1 = Dim1 * mult,
                PCoA2 = Dim2 * mult)

pcoa_sub_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, color = TRAT2)) +
  geom_segment(data = arrows_df,
               aes(x = 0, y = 0, xend = PCoA1*0.5, yend = PCoA2*0.5),
               arrow = arrow(length = unit(0.2, "cm")),
               size = 1, color = "grey",
               inherit.aes = FALSE) +
  geom_point(size = 5, alpha = .6) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  ) +
  scale_x_reverse()
ggsave("PCoA_sub.png")

# Plot PCoA
pcoa_sub_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, color = TRAT2)) +
  geom_segment(data = arrows_df,
               aes(x = 0, y = 0, xend = PCoA1*0.4, yend = PCoA2*0.4), # xend and yend *0.5 to reduce arrow lenght
               arrow = arrow(length = unit(0.2, "cm")),
               size =1, color = "darkgrey",
               inherit.aes = FALSE) +  
  geom_text(data = arrows_df,
            aes(x = PCoA1, y = PCoA2, label = Variable),
            size = 4, hjust = 0.5, vjust = -0.7,
            inherit.aes = FALSE) +  
  geom_point(size = 6, alpha=.5) +
  scale_color_manual(values = cols) +
  #theme_minimal() +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none") +
  scale_x_reverse()
#ggsave("PCoA_sub.png")
```

```{r PCoA as linear predictor}
#TOPSOIL
lm_pcoa_top <- lm(PCoA1 ~ TRAT2, data = pcoa_top_df)
summary(lm_pcoa_top)

ggplot(pcoa_top_df, aes(x = TRAT2, y = PCoA1, color=TRAT2, fill = TRAT2)) +
  geom_boxplot(alpha = 0.3) +
  geom_jitter(width = 0.1, aes(color = TRAT2)) +
  scale_fill_manual(values = cols) +
  scale_color_manual(values = cols) +
  theme_minimal()+
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("lm_pcoa_top.png")

anova(lm(PCoA1 ~ TRAT2, data = pcoa_top_df))
Tuckeys <- TukeyHSD(aov(PCoA1 ~ TRAT2, data = pcoa_top_df))
cld <- multcompLetters4(lm_pcoa_top, Tuckeys)
print(cld)

#SUBSOIL
lm_pcoa_sub <- lm(PCoA1 ~ TRAT2, data = pcoa_sub_df)
summary(lm_pcoa_sub)

ggplot(lm_pcoa_sub, aes(x = TRAT2, y = PCoA1, color=TRAT2, fill = TRAT2)) +
  geom_boxplot(alpha = 0.3) +
  geom_jitter(width = 0.1, aes(color = TRAT2)) +
  scale_fill_manual(values = cols) +
  scale_color_manual(values = cols) +
  theme_minimal()+
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("lm_pcoa_sub.png")

anova(lm(PCoA1 ~ TRAT2, data = pcoa_sub_df))
Tuckeys <- TukeyHSD(aov(PCoA1 ~ TRAT2, data = pcoa_sub_df))
cld <- multcompLetters4(lm_pcoa_sub, Tuckeys)
print(cld)
```

```{r Combined plots for PCoA}
# PCoA SUBSOIL
p3 <- pcoa_top_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, color = TRAT2)) +
  geom_segment(data = arrows_df,
               aes(x = 0, y = 0, xend = PCoA1*0.5, yend = PCoA2*0.5),
               arrow = arrow(length = unit(0.2, "cm")),
               size = 1, color = "grey",
               inherit.aes = FALSE) +
  geom_point(size = 5, alpha = .6) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  ) +
  scale_x_reverse()

# Boxplot
p4 <- ggplot(lm_pcoa_top, aes(x = TRAT2, y = PCoA1, color = TRAT2, fill = TRAT2)) +
  geom_boxplot(alpha = 0.2) +
  geom_jitter(width = 0.1, size = 2) +
  scale_fill_manual(values = cols) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "Treatment", y = "PCoA 1") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
combined_plot <- p3 + p4 + plot_layout(ncol = 2, widths = c(2, 1))
combined_plot
#ggsave("combined_topsoil.png")

# PCoA SUBSOIL
p1 <- pcoa_sub_df %>%
  ggplot(aes(x = PCoA1, y = PCoA2, color = TRAT2)) +
  geom_segment(data = arrows_df,
               aes(x = 0, y = 0, xend = PCoA1*0.5, yend = PCoA2*0.5),
               arrow = arrow(length = unit(0.2, "cm")),
               size = 1, color = "grey",
               inherit.aes = FALSE) +
  geom_point(size = 5, alpha = .6) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "PCoA 1", y = "PCoA 2") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  ) +
  scale_x_reverse()

# Boxplot
p2 <- ggplot(lm_pcoa_sub, aes(x = TRAT2, y = PCoA1, color = TRAT2, fill = TRAT2)) +
  geom_boxplot(alpha = 0.2) +
  geom_jitter(width = 0.1, size = 2) +
  scale_fill_manual(values = cols) +
  scale_color_manual(values = cols) +
  theme_minimal() +
  labs(x = "Treatment", y = "PCoA 1") +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
combined_plot <- p1 + p2 + plot_layout(ncol = 2, widths = c(2, 1))
combined_plot
#ggsave("combined_subsoil.png")
```

```{r PERMANOVA}
permanova <- vegan::adonis2(bray_dist ~ TRAT2 * DEPTH, permutations = 999, data = ps_hel_meta_data)
permanova
#Model R2 = the proportion of total variation in the Bray-Curtis distances that is explained by TRAT2
#Residual R2: This is the proportion of variation not explained by TRAT2
#F: higher values mean stronger between-group vs within-group differences.

# Check dispersion
disp <- betadisper(bray_dist, ps_hel_meta_data$DEPTH)
anova(disp)
permutest(disp)
permutest(disp, pairwise=TRUE)

####TOPSOIL
meta_data_top <- ps_hel_meta_data %>% dplyr::filter(DEPTH=="topsoil")
permanova_top <- vegan::adonis2(bray_dist_top ~ TRAT2, permutations = 999, data = meta_data_top)
permanova_top

disp_top <- betadisper(bray_dist_top, meta_data_top$TRAT2)
anova(disp_top)

#png("betadisp_top_plot.png", width = 1200, height = 1200, res = 300)
plot(disp_top)
#dev.off()

####SUBSOIL
meta_data_sub <- ps_hel_meta_data %>% dplyr::filter(DEPTH=="subsoil")
permanova_sub <- vegan::adonis2(bray_dist_sub ~ TRAT2, permutations = 999, data = meta_data_sub)
permanova_sub

disp_sub <- betadisper(bray_dist_sub, meta_data_sub$TRAT2)
anova(disp_sub)

#png("betadisp_plot.png", width = 1200, height = 1200, res = 300)
plot(disp)
#dev.off()
```

```{r UniFrac}
# We first calculate the phylogenetic distances: 

ps1_top <- subset_samples(ps1, DEPTH == "topsoil")
ps1_sub <- subset_samples(ps1, DEPTH == "subsoil")

ordu_unw <- UniFrac(ps1_sub)

# Conduct a PCoA:
unifrac.pcoa = ordinate (ps1_sub, method = "PCoA", distance = ordu_unw)

pcoa_df <- plot_ordination(ps1_sub, unifrac.pcoa, type = "samples", justDF = TRUE)
 
ggplot(pcoa_df, aes(x = Axis.1, y = Axis.2, color = TRAT2)) +
  stat_ellipse(type = "t", linetype = 2, linewidth = 0.7, alpha = 0.6) +
  geom_point(size = 4, alpha = 0.9) +
  labs(
    x = paste0("PCoA1 (", round(100 * unifrac.pcoa$values$Relative_eig[1], 1), "%)"),
    y = paste0("PCoA2 (", round(100 * unifrac.pcoa$values$Relative_eig[2], 1), "%)"),
    color = "Fire severity"
  ) +
  theme_bw(base_size = 14) +
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14)
  )
#ggsave("Unifrac_sub.png")

#PERMANOVA

permanova_unifrac <- vegan::adonis2(
  ordu_unw ~ TRAT2,
  data = as(sample_data(ps1_top), "data.frame"),
  permutations = 999
)
permanova_unifrac

disp_UNI <- betadisper(ordu_unw, (data = as(sample_data(ps1_top), "data.frame")$TRAT2))
anova(disp_UNI)
```

```{r RandomForest} 
# It's a regression formula. We should have a data.frame were the first column is the response variable and the remaining columns are the predictor variables
for_RF <- alpha_fungi %>% 
  mutate(Fe_g_Kg = Fe_mg_Kg_105/1000,
         C_N_ratio = Ctotal_g_100g_105/Ntotal_g_100g_105)

RF_vars <- c("observed", "pH", "EC", "C_N_ratio",
              "A_phosphorus_ppm_105", "Phosphatase_activity_췃mol_g_h", 
              "NH4_mgL_105","NO3_mgL_105", 
              "Ntotal_g_100g_105", "Ctotal_g_100g_105", "Carbon_stock_Mg_ha",
              "Nitrogen_stock_Mg_ha", "SOM_per_corregido", "MBC_mg_kg_105",
              "Nematode_g_105", "Ca_g_kg", "K_g_kg","Mg_g_kg", "Na_g_kg", 
              "Al_g_kg", "Fe_g_Kg","Zn_mg_Kg_105", "Cu_mg_Kg_105")

for_RF <- for_RF %>% filter(DEPTH=="subsoil")

RF_indicators <- for_RF %>%
  dplyr::select(all_of(RF_vars))

# 2) Create the 6 "soil function" categories with their mean and standard error: 
RF_functions_calc <- for_RF %>%
  dplyr::group_by(SampleID,TRAT2, DEPTH) %>% #We need to include ID because we want an individual value of Soil Function per sample
  dplyr::mutate(
    Soil_properties = mean(c(pH, EC), na.rm = TRUE),
    Soil_fertility = mean(c(A_phosphorus_ppm_105, NH4_mgL_105, NO3_mgL_105, Ntotal_g_100g_105, Nitrogen_stock_Mg_ha, C_N_ratio,  Ca_g_kg, K_g_kg, Mg_g_kg, Na_g_kg), na.rm = TRUE),
    Carbon_sequestration = mean(c(Ctotal_g_100g_105, SOM_per_corregido, Carbon_stock_Mg_ha), na.rm = TRUE),
    Nutrient_cycling = mean(c(Phosphatase_activity_췃mol_g_h, MBC_mg_kg_105), na.rm = TRUE),
    Metals = mean(c(Al_g_kg, Cu_mg_Kg_105, Fe_g_Kg, Zn_mg_Kg_105), na.rm = TRUE),
    Soil_biodiversity = mean(c(Nematode_g_105), na.rm = TRUE))

functions <- c("observed", "Soil_properties", "Soil_fertility", "Carbon_sequestration", "Nutrient_cycling", "Metals", "Soil_biodiversity")

RF_functions <- RF_functions_calc %>%
  dplyr::select(all_of(functions)) %>%
  dplyr::filter(DEPTH=="subsoil")

RF_functions <- RF_functions[,4:10]

data <- RF_indicators
data <- data %>% #This implies that column ncol(data) is the response variable
  dplyr::select(ncol(data), everything())
#Model training
set.seed(12)
RFfit<- randomForest(observed ~ ., data=data, ntree=300, importance=T) # necesario importance=T para guardar el valor de las importancias
summary(RFfit)
#Error plot
plot(RFfit)

#Variable importance
importance_matrix <- importance(RFfit)
incMSE_values <- importance_matrix[, "%IncMSE"]

#png("RFfit_plot.png", width = 800, height = 600)
varImpPlot(RFfit)
#dev.off()
#incMSE indica el error por permutacion
#incNodePurity indica la capacidad de esa variable para separar nodos

# Convertir a dataframe
incMSE_df <- data.frame(Variable = rownames(importance_matrix),
                        IncMSE = importance_matrix[, "%IncMSE"])
# Ordenar las variables de mayor a menor incremento en el MSE
incMSE_df <- incMSE_df[order(incMSE_df$IncMSE, decreasing = TRUE), ]
# Ver los resultados
print(incMSE_df)

ggplot(incMSE_df, aes(x = reorder(Variable, IncMSE), y = IncMSE, fill = IncMSE)) +
  geom_col() +
  coord_flip() +
  theme_minimal() +
  theme(
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank()  # Remove strip background
  )
#ggsave("RandomForest_SUBSOIL2.png", height = 5, width = 6, dpi = 300)
```

```{r rfPermute}
#If we need statistical significance, we will use the rfPermute package (same base as RandomForest)
#set.seed(8)
rp <- rfPermute(observed ~ ., data=data, ntree = 300, num.rep = 1000, num.cores = 6)
importance_matrix <- importance(rp)
plotImportance(rp)
summary(rp)

incMSE_df <- data.frame(Variable = rownames(importance_matrix),
                        IncMSE = importance_matrix[, "%IncMSE"],
                        pvalueIncMSE = importance_matrix[,"%IncMSE.pval"])

incMSE_df$pvalueIncMSE <- ifelse(incMSE_df$pvalueIncMSE < 0.05, "Significant", "Not Significant")

incMSE_df <- incMSE_df[order(incMSE_df$IncMSE, decreasing = TRUE), ]
# Ver los resultados
print(incMSE_df)

ggplot(incMSE_df, aes(x = reorder(Variable, IncMSE), y = IncMSE, fill= pvalueIncMSE)) +
  geom_col() +
  scale_fill_manual(values=c("#969696", "#4d004b"))+
  #scale_fill_viridis(option="D",direction = -1) +
  coord_flip() +
  theme_minimal() +
  theme(
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    strip.background = element_blank()  # Remove strip background
  )
#ggsave("rfPermute_SUBSOIL.png", height = 5, width = 6, dpi = 300)
```
*We've run all these analysis with the raw data and the Hellinger transformed data and results are practically the same*
Species are chosen as indicators if they:

1. Reflect the biotic or abiotic state of the environment;
2. Provide evidence for the impacts of environmental change; or
3. Predict the diversity of other species, taxa or communities within an area.

The *IndicSpecies Analysis* tells us:
-Which ASVs (or taxa) are statistically associated with particular treatment groups (UB, LS, HS1, HS2).
-A value = specificity (how exclusive the ASV is to a group),
-B value = fidelity (how frequent the ASV is in that group)
*Good for identifying indicator taxa for specific conditions* (e.g., taxa that define unburned soils vs high-severity fire soils)

```{r Indicator Species Analysis}
## Species are chosen as indicators if they:
# 1) Reflect the biotic or abiotic state of the environment;
# 2) Provide evidence for the impacts of environmental change; or
# 3) Predict the diversity of other species, taxa or communities within an area.

#Indicator species are often determined using an analysis of the relationship between the species occurrence or abundance values from a set of sampled sites and the classification of the same sites into site groups, which may represent habitat types, community types, disturbance states, etc. Thus, there are two data elements in an indicator species analysis: 
###############################
# (1) the community data matrix --> with sites in rows and species in columns
# (2) the vector that describes the classification of sites into groups --> a vector containing the classification of the sites into groups

ps1_genus_metadata #from the FungalTraits code
otu_mat_genus #community data (abundance matrix) from the FungalTraits code
head(otu_mat_genus)

# Transpose the table
asv_transposed <- as.data.frame(t(otu_mat_genus))
head(asv_transposed)
asv_transposed <- as.matrix(asv_transposed)

#Now we need to code the vector of site groups. We want to do 4 groups: UB, LS, HS1, HS2
head(ps1_genus_metadata$TRAT2)
groups4 <- as.factor(ps1_genus_metadata$TRAT2)

#Indicator species analysis
indval <- indicspecies::multipatt(asv_transposed, groups4, 
                    control = how(nperm=999)) # El argumento control = how(nperm=999) permite elegir el n칰mero de permutaciones aleatorias requeridas para la prueba de permutaci칩n (este n칰mero afecta la precisi칩n del valor p). La funci칩n how() del paquete permute permite definir dise침os permutacionales m치s complejos
summary(indval) 

indval_results <- indval$sign
#The first columns indicate (with ones and zeroes) which site groups were included in the combination preferred by the species. Then, the column indicates the index of the site group combination. The remaining two columns are the association statistic and the p-value of the permutational test.
indval_df <- data.frame(ASV = rownames(indval_results), indval_results)
df_tax <-  as.data.frame((tax_table(ps1_genus)))
df_tax <- df_tax %>% 
  tibble::rownames_to_column(var = "ASV")
indicator_with_taxonomy4 <- merge(indval_df, df_tax, by = "ASV")

# A침adir indvalcomp = TRUE" a la funci칩n anterior nos brinda informaci칩n adicional sobre por qu칠 las especies pueden usarse como indicadores:
summary(indval, indvalcomp=TRUE)
# A value will tell us if the species is a good indicator of that group (1 = the best indicator)
# B value will tell us if the species appears in all the plots of the group 

# Al a침adir alfa = 1, decimos que queremos mostrar el grupo al que est치 asociada cada especie, independientemente de si la asociaci칩n es significativa o no. (por defecto viene establecido alpha 0,05, que se corresponde al valor de significancia que  tiene en cuenta el an치lisis de permutaci칩n)  
summary(indval, indvalcomp=TRUE, alpha=1) 

# Filter only significant indicators
sig_indicators <- indicator_with_taxonomy4 %>%
  dplyr::filter(p.value <= 0.05) 
```

```{r Species Indicator Analysis: TOPSOIL}
## Phylum
ps1_phylum_metaTOP <- as(sample_data(ps1_phylum_topsoil), "data.frame") # metadata
otu_mat_TOP <- as.data.frame(as.matrix(otu_table(ps1_phylum_topsoil))) # abundance matrix
# Transpose the table
asv_trans_TOP <- as.data.frame(t(otu_mat_TOP))
asv_trans_TOP <- as.matrix(asv_trans_TOP)
# Defining site groups: UB, LS, HS1, HS2
head(ps1_phylum_metaTOP$TRAT2)
groups4_TOP <- as.factor(ps1_phylum_metaTOP$TRAT2)

indval_TOP <- indicspecies::multipatt(asv_trans_TOP, groups4_TOP, control = how(nperm=999))
summary(indval_TOP, indvalcomp=TRUE)

# Genus
ps1_genus_metaTOP <- as(sample_data(ps1_genus_topsoil), "data.frame") # metadata
otu_mat_TOP <- as.data.frame(as.matrix(otu_table(ps1_genus_topsoil))) # abundance matrix
# Transpose the table
asv_trans_TOP <- as.data.frame(t(otu_mat_TOP))
asv_trans_TOP <- as.matrix(asv_trans_TOP)
# Defining site groups: UB, LS, HS1, HS2
head(ps1_genus_metaTOP$TRAT2)
groups4_TOP <- as.factor(ps1_genus_metaTOP$TRAT2)

set.seed(321) 
indval_TOP <- indicspecies::multipatt(asv_trans_TOP, groups4_TOP, control = how(nperm=999))
summary(indval_TOP, indvalcomp=TRUE)

#Extract significant indicator taxa and link to taxonomy
indval_df_TOP <- data.frame(ASV = rownames(indval_TOP$sign), indval_TOP$sign)
df_tax_top <-  as.data.frame((tax_table(ps1_genus_topsoil)))
df_tax_top <- df_tax_top %>% 
  tibble::rownames_to_column(var = "ASV")
indicator_with_taxTOP <- merge(indval_df_TOP, df_tax_top, by = "ASV")
indicator_with_taxTOP$Genus <- gsub("^g__", "", indicator_with_taxTOP$Genus)
# Filter only significant indicators
sig_TOP_ind <- indicator_with_taxTOP %>%
  dplyr::filter(p.value <= 0.05) 

# Relative abundance per fire severity
ps1_genus_topsoil_rel <- transform_sample_counts(ps1_genus_topsoil, function(x) x / sum(x)) ## Relative abundance PER SAMPLE. Each sample뗩 abundances now sum to 1 (or 100%)
df_rel_top <- psmelt(ps1_genus_topsoil_rel) 
df_rel_top$ASV <- df_rel_top$OTU

abund_perc_top <- df_rel_top %>%      ## Aggregation by fire severity
  dplyr::group_by(TRAT2, ASV) %>%
  dplyr::summarise(mean_abundance = mean(Abundance), .groups = "drop") %>%
  dplyr::mutate(percent = 100 * mean_abundance)

#######
trial <- df_rel_top %>%
  dplyr::group_by(OTU) %>%
  dplyr::summarise(Abundance = sum(Abundance), .groups = "drop") %>%
  dplyr::mutate(Abundance = Abundance / sum(Abundance))
abund_perc_top <- df_rel_top %>%
  dplyr::mutate(percent = 100 * Abundance)
TOP_abundances_0 <- left_join(plot_data_top, abund_perc_top, by = c("ASV"))


##########

#Match indicator taxa with their abundances
plot_data_top <- sig_TOP_ind %>%
  pivot_longer(cols = starts_with("s."), names_to = "TRAT2", values_to = "Presence") %>%
  dplyr::filter(Presence == 1) %>%
  dplyr::mutate(TRAT2 = gsub("^s\\.", "", TRAT2))  # remove prefix like 's.HS1'  'HS1'

plot_data_top$TRAT2 <- factor(plot_data_top$TRAT2, ordered =FALSE)

TOP_abundances <- left_join(plot_data_top, abund_perc_top, by = c("ASV", "TRAT2"))

## BUBBLE PLOT
TOP_abundances <- TOP_abundances %>%
  dplyr::filter(percent > 5) 
  #dplyr::filter(stat > 0.5)
  
TOP_abundances %>%
  dplyr::group_by(TRAT2) %>%
  dplyr::summarise(sum_per = sum(percent))

TOP_abundances$TRAT2 <- ordered(TOP_abundances$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

b1 <- ggplot(TOP_abundances, aes(x = stat, y = Genus, color = stat)) +
  geom_segment(aes(x = 0, xend = stat, y = Genus, yend = Genus),
               color = "grey30", linetype = "dashed", linewidth = 0.5, alpha = 0.6) +
  geom_point(aes(size = percent, color=stat), alpha=0.7) +
  scale_size_continuous(name = "Mean relative abundance (%)")+
  scale_color_viridis_c(option = "C", direction = -1, name = "IndVal") +
  labs(
    x = "Indicator Value (IndVal)",
    y = "Genus",
    title = "Indicator Genera by Fire Severity (Topsoil)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    legend.position = "none",
    #strip.background = element_blank()  # Remove strip background
  ) +
  scale_y_discrete() +
  scale_x_continuous(expand = expansion(mult = c(-0.7, 0.05))) +
  facet_wrap(~TRAT2, nrow = 1)
#ggsave("bubbles_indspecies_TOP.png", width = 8, height = 5, dpi = 300) #### FIGURE 5a ####
```

```{r Species Indicator Analysis: SUBSOIL}
# Phylum
ps1_phylum_metaSUB <- as(sample_data(ps1_phylum_subsoil), "data.frame") # metadata
otu_mat_SUB <- as.data.frame(as.matrix(otu_table(ps1_phylum_subsoil))) # abundance matrix
# Transpose the table
asv_trans_SUB <- as.data.frame(t(otu_mat_SUB))
asv_trans_SUB <- as.matrix(asv_trans_SUB)
# Defining site groups: UB, LS, HS1, HS2
head(ps1_phylum_metaSUB$TRAT2)
groups4_SUB <- as.factor(ps1_phylum_metaSUB$TRAT2)

#set.seed(321)
indval_SUB <- indicspecies::multipatt(asv_trans_SUB, groups4_SUB, control = how(nperm=999))
summary(indval_SUB, indvalcomp=TRUE)

#GENUS
ps1_genus_metaSUB <- as(sample_data(ps1_genus_subsoil), "data.frame") # metadata
otu_mat_SUB <- as.data.frame(as.matrix(otu_table(ps1_genus_subsoil))) # abundance matrix
# Transpose the table
asv_trans_SUB <- as.data.frame(t(otu_mat_SUB))
asv_trans_SUB <- as.matrix(asv_trans_SUB)
# Defining site groups: UB, LS, HS1, HS2
head(ps1_genus_metaSUB$TRAT2)
groups4_SUB <- as.factor(ps1_genus_metaSUB$TRAT2)

set.seed(321)
indval_SUB <- indicspecies::multipatt(asv_trans_SUB, groups4_SUB, control = how(nperm=999))
summary(indval_SUB, indvalcomp=TRUE)

indval_df_SUB <- data.frame(ASV = rownames(indval_SUB$sign), indval_SUB$sign)
df_tax_sub <-  as.data.frame((tax_table(ps1_genus_subsoil)))
df_tax_sub <- df_tax_sub %>% 
  tibble::rownames_to_column(var = "ASV")
indicator_with_taxSUB <- merge(indval_df_SUB, df_tax_sub, by = "ASV")
indicator_with_taxSUB$Genus <- gsub("^g__", "", indicator_with_taxSUB$Genus)
# Filter only significant indicators
sig_SUB_ind <- indicator_with_taxSUB %>%
  dplyr::filter(p.value <= 0.05) 

# Relative abundance per fire severity
ps1_genus_subsoil_rel <- transform_sample_counts(ps1_genus_subsoil, function(x) x / sum(x))

df_rel_sub <- psmelt(ps1_genus_subsoil_rel) 
df_rel_sub$ASV <- df_rel_sub$OTU

abund_perc_sub <- df_rel_sub %>%
  dplyr::group_by(TRAT2, ASV) %>%
  dplyr::summarise(mean_abundance = mean(Abundance), .groups = "drop") %>%
  dplyr::mutate(percent = 100 * mean_abundance)

plot_data_sub <- sig_SUB_ind %>%
  pivot_longer(cols = starts_with("s."), names_to = "TRAT2", values_to = "Presence") %>%
  dplyr::filter(Presence == 1) %>%
  dplyr::mutate(TRAT2 = gsub("^s\\.", "", TRAT2))  # remove prefix like 's.HS1'  'HS1'

plot_data_sub$TRAT2 <- factor(plot_data_sub$TRAT2, ordered =FALSE)

SUB_abundances <- left_join(plot_data_sub, abund_perc_sub, by = c("ASV", "TRAT2"))

vista <- SUB_abundances %>% dplyr::filter(ASV =="ASV_73")

## BUBBLE PLOT
SUB_abundances <- SUB_abundances %>%
  dplyr::filter(percent > 5)

SUB_abundances$TRAT2 <- ordered(SUB_abundances$TRAT2, levels=c("UB", "LS", "HS1", "HS2"))

b2 <- ggplot(SUB_abundances, aes(x = stat, y = Genus, color = stat)) +
  geom_segment(aes(x = 0, xend = stat, y = Genus, yend = Genus),
               color = "grey30", linetype = "dashed", linewidth = 0.5, alpha = 0.6) +
  geom_point(aes(size = percent, color = stat), alpha=0.7) +
  scale_size_continuous(name = "Mean relative abundance (%)")+
  scale_color_viridis_c(option = "C", direction = -1, name = "IndVal") +
  labs(
    x = "Indicator Value (IndVal)",
    y = "Genus",
    title = "Indicator Genera by Fire Severity (Subsoil)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(colour = "black", fill = NA),
    #panel.grid = element_blank(),
    #panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    strip.placement = "outside",  # Place strip labels outside the plot
    legend.position = "none",
    #strip.background = element_blank()  # Remove strip background
  ) +
  #scale_y_discrete() +
  scale_x_continuous(expand = expansion(mult = c(-0.7, 0.05))) +
  facet_wrap(~TRAT2, nrow = 1)
#ggsave("SUPP_bubbles_indspecies_SUBx.png", width = 6, height = 4, dpi = 300) #### FIGURE 5b ####
```

```{r Combined topsoil & subsoil Indicator Species}
combined_plot <- b1 + b2 + plot_layout(ncol = 2, widths = c(2, 2))
combined_plot
ggsave("combined_indic2.png", combined_plot, width = 10, height = 4.2, dpi = 300)
```

```{r Venn Diagram}
## TOPSOIL
ps1_genus_metaTOP$TRAT2 <- ordered(ps1_genus_metaTOP$TRAT2,
                                  levels = c("UB", "LS", "HS1", "HS2")) # metadata
asv_trans_TOP <- as.data.frame(asv_trans_TOP) #transposed otu mat

#Transform to presence/absence
asv_trans_TOP[asv_trans_TOP > 0] <- 1

#Filter by indicator genera
otu_top_ind <- asv_trans_TOP[, colnames(asv_trans_TOP) %in% sig_TOP_ind$ASV]

#Group by fire severity
otu_by_TOP <- otu_top_ind %>%
  dplyr::mutate(TRAT2 = ps1_genus_metaTOP$TRAT2) %>%
  dplyr::group_by(TRAT2) %>%
  dplyr::summarise(across(everything(), max)) 

# Convertir a listas de ASVs por TRAT2
venn_list_top <- lapply(otu_by_TOP$TRAT2, function(trat) {
  colnames(otu_by_TOP)[which(otu_by_TOP[otu_by_TOP$TRAT2 == trat, -1] == 1)]
})
names(venn_list_top) <- otu_by_TOP$TRAT2

venn.diagram(
  x = venn_list_top,
  filename = "00.png",
  output=TRUE, 
  fill = c("#41b6c4","#fd8d3c","#cb181d","#800026"),  
  alpha = 0.6,
  #cex = 1.2,
  #cat.cex = 1.2,
  category.names = names(venn_list_top),
  main = "Shared Indicator Genera by Fire Severity (Topsoil)"
) #### FIGURE 5c ####

## SUBSOIL
ps1_genus_metaSUB$TRAT2 <- ordered(ps1_genus_metaSUB$TRAT2,
                                  levels = c("UB", "LS", "HS1", "HS2")) # metadata # metadata
asv_trans_SUB <- as.data.frame(asv_trans_SUB) #transposed otu mat

#Transform to presence/absence
asv_trans_SUB[asv_trans_SUB > 0] <- 1

#Filter by indicator genera
otu_sub_ind <- asv_trans_SUB[, colnames(asv_trans_SUB) %in% sig_SUB_ind$ASV]

#Group by fire severity
otu_by_SUB <- otu_sub_ind %>%
  dplyr::mutate(TRAT2 = ps1_genus_metaSUB$TRAT2) %>%
  dplyr::group_by(TRAT2) %>%
  dplyr::summarise(across(everything(), max)) 

# Convertir a listas de ASVs por TRAT2
venn_list_sub <- lapply(otu_by_SUB$TRAT2, function(trat) {
  colnames(otu_by_SUB)[which(otu_by_SUB[otu_by_SUB$TRAT2 == trat, -1] == 1)]
})
names(venn_list_sub) <- otu_by_SUB$TRAT2

venn.diagram(
  x = venn_list_sub,
  filename = "SUBSOIL_ind_venn_diagramm.png",
  output=TRUE, 
  fill = c("#41b6c4","#fd8d3c","#cb181d","#800026"), 
  alpha = 0.6,
  #cex = 1.2,
  #cat.cex = 1.2,
  category.names = names(venn_list_sub),
  main = "Shared Indicator Genera by Fire Severity (Subsoil)"
) #### FIGURE 5d ####
```

```{r Microbiome network plot}

plot_net(ps1,color="TRAT2")

```

```{r RDA TOPSOIL}
otu_rda_top <- t(as.data.frame(otu_table(ps_hel_topsoil)))
meta_rda_top <- data.frame(sample_data(ps_hel_topsoil))

meta_rda_top <- meta_rda_top %>% 
  dplyr::mutate(Fe_g_Kg = Fe_mg_Kg_105/1000,
         C_N_ratio = Ctotal_g_100g_105/Ntotal_g_100g_105)
#Matrix with explanatory variables
rda_explanatory <- meta_rda_top[,c("pH", "EC", "C_N_ratio",
              "A_phosphorus_ppm_105", "Phosphatase_activity_췃mol_g_h", 
              "NH4_mgL_105","NO3_mgL_105", 
              "Ntotal_g_100g_105", "Ctotal_g_100g_105", "Carbon_stock_Mg_ha",
              "Nitrogen_stock_Mg_ha", "SOM_per_corregido", "MBC_mg_kg_105",
              "Nematode_g_105", "Ca_g_kg", "K_g_kg","Mg_g_kg", "Na_g_kg", 
              "Al_g_kg", "Fe_g_Kg","Zn_mg_Kg_105", "Cu_mg_Kg_105")]

#alpha_fung_top <- alpha_fungi %>% filter(DEPTH=="topsoil")
# Run the RDA
rda_model_top <- rda(otu_rda_top ~ .,
                 data = rda_explanatory)
summary(rda_model_top)
#plot(rda_model, scaling = 2)

anova(rda_model_top)               # Overall significance

anova_terms <- anova(rda_model_top, by = "terms") # Variable significance
sig_vars <- rownames(anova_terms)[anova_terms$`Pr(>F)` < 0.05]
sig_vars

## extract % explained by the first 2 axes
perc <- round(100*(summary(rda_model_top)$cont$importance[2, 1:2]), 2)
## extract scores - these are coordinates in the RDA space
sc_si <- vegan::scores(rda_model_top, display="sites", choices=c(1,2), scaling=1) %>% as.data.frame
sc_bp <- vegan::scores(rda_model_top, display="bp", choices=c(1, 2), scaling=1)  %>% as.data.frame
sc_bp <- sc_bp[sig_vars, ,drop=FALSE]
sc_bp$Variable <- rownames(sc_bp)

rownames(sc_si) == rownames(meta_rda_top)
sc_si$Variable <- rownames(sc_si)
RDA <- cbind(meta_rda_top, sc_si)

sc_bp_scaled <- sc_bp
sc_bp_scaled$RDA1 <- sc_bp_scaled$RDA1 * 2
sc_bp_scaled$RDA2 <- sc_bp_scaled$RDA2 * 2

h1 <- ggplot(RDA, aes(x = RDA1, y = RDA2, color = TRAT2)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_point(size = 5, alpha = 0.7) +
  scale_color_manual(values = cols) +
  geom_segment(data = sc_bp_scaled,
               aes(x = 0, y = 0, xend = RDA1, yend = RDA2),
               arrow = arrow(length = unit(0.25, "cm")),
               color = "grey10",
               inherit.aes = FALSE) +
  
  coord_fixed(
    xlim = range(c(sc_si$RDA1, sc_bp_scaled$RDA1)) ,
    ylim = range(c(sc_si$RDA2, sc_bp_scaled$RDA2)) 
  ) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid = element_blank(),
    legend.position = "none",
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", hjust = 0.5)
  ) +
  labs(
    title = "Triplot RDA (scaling 1)",
    x = paste0("RDA1 (", perc[1], "%)"),
    y = paste0("RDA2 (", perc[2], "%)"),
    color = "Fire severity"
  )
#ggsave("RDA_TOPSOIL2.png")
```

```{r RDA SUBSOIL}
otu_rda_sub <- t(as.data.frame(otu_table(ps_hel_subsoil)))
meta_rda_sub <- data.frame(sample_data(ps_hel_subsoil))

meta_rda_sub <- meta_rda_sub %>% 
  dplyr::mutate(Fe_g_Kg = Fe_mg_Kg_105/1000,
         C_N_ratio = Ctotal_g_100g_105/Ntotal_g_100g_105)
#Matrix with explanatory variables
rda_explanatory <- meta_rda_sub[,c("pH", "EC", "C_N_ratio",
              "A_phosphorus_ppm_105", "Phosphatase_activity_췃mol_g_h", 
              "NH4_mgL_105","NO3_mgL_105", 
              "Ntotal_g_100g_105", "Ctotal_g_100g_105", "Carbon_stock_Mg_ha",
              "Nitrogen_stock_Mg_ha", "SOM_per_corregido", "MBC_mg_kg_105",
              "Nematode_g_105", "Ca_g_kg", "K_g_kg","Mg_g_kg", "Na_g_kg", 
              "Al_g_kg", "Fe_g_Kg","Zn_mg_Kg_105", "Cu_mg_Kg_105")]

#alpha_fung_sub <- alpha_fungi %>% filter(DEPTH=="subsoil")
# Run the RDA
rda_model <- rda(otu_rda_sub ~ ., data = rda_explanatory)
summary(rda_model)
plot(rda_model, scaling = 2)
ordiplot(rda_model, scaling = 1)

anova(rda_model)               # Overall significance
anova_terms <- anova(rda_model, by = "terms") # Variable significance
sig_vars <- rownames(anova_terms)[anova_terms$`Pr(>F)` < 0.05]
sig_vars
anova(rda_model, by = "terms")
# Custom triplot code!

## extract % explained by the first 2 axes
perc <- round(100*(summary(rda_model)$cont$importance[2, 1:2]), 2)
## extract scores - these are coordinates in the RDA space
sc_si <- vegan::scores(rda_model, display="sites", choices=c(1,2), scaling=1) %>% as.data.frame
sc_bp <- vegan::scores(rda_model, display="bp", choices=c(1, 2), scaling=1)  %>% as.data.frame
sc_bp <- sc_bp[sig_vars, ,drop=FALSE]
sc_bp$Variable <- rownames(sc_bp)

rownames(sc_si) == rownames(meta_rda_sub)
RDA <- cbind(meta_rda_sub, sc_si)

sc_bp_scaled <- sc_bp
sc_bp_scaled$RDA1 <- sc_bp_scaled$RDA1 * 2
sc_bp_scaled$RDA2 <- sc_bp_scaled$RDA2 * 2

h2 <- ggplot(RDA, aes(x = RDA1, y = RDA2, color = TRAT2)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_point(size = 5, alpha = 0.7) +
  scale_color_manual(values = cols) +
  geom_segment(data = sc_bp_scaled,
               aes(x = 0, y = 0, xend = RDA1, yend = RDA2),
               arrow = arrow(length = unit(0.25, "cm")),
               color = "grey10",
               inherit.aes = FALSE) +
 
  coord_fixed(
    xlim = range(c(sc_si$RDA1, sc_bp_scaled$RDA1)) ,
    ylim = range(c(sc_si$RDA2, sc_bp_scaled$RDA2)) 
  ) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid = element_blank(),
    legend.position = "none",
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", hjust = 0.5)
  ) +
  labs(
    title = "Triplot RDA (scaling 1)",
    x = paste0("RDA1 (", perc[1], "%)"),
    y = paste0("RDA2 (", perc[2], "%)"),
    color = "Fire severity"
  )
#ggsave("RDA_SUBSOIL.png")
```

```{r}
combined_plot <- h1 + h2 + plot_layout(ncol = 1, heights = c(3, 2))
combined_plot
ggsave("combined_RDA.png", width = 5, height = 8, dpi = 300)
```

############################ EXTRA ##############################################

```{r Sankey Diagram}
## We need two dataframes:
# Nodes: with a number for each node we want to represent (ins and outs) --> e.g.: 1-UB, 2-LS, 3-HS1... Two columns
# Links: Three columns. Source (from 0 to n췈 nodes - 1), Target and Value
h <- ps3meltrel %>%
  dplyr::group_by(TRAT2, DEPTH, Phylum) %>%
  dplyr::summarise(total_abundance = sum(Abundance, na.rm = TRUE))

#write.csv(h, "ps4melted.csv") --> we make the codification in Excel

links <- as.data.frame(read_excel("C:/Users/amara.santiesteban/OneDrive - UAM/Escritorio/Sankey_trial.xlsx", sheet = "Links"))
nodes <- as.data.frame(read_excel("C:/Users/amara.santiesteban/OneDrive - UAM/Escritorio/Sankey_trial.xlsx", sheet = "Nodes"))

sankey <- networkD3::sankeyNetwork(Links = links, Nodes = nodes, Source = "source",
               Target = "target", Value = "Value", NodeID = "names",  iterations = 0) #Setting "iterations = 0" will disable the algorithm which automatically determines the node placement, and the nodes will be placed in the order that they appear in the Nodes dataframe.

pdf_file <- "sankey_diagram.pdf"
webshot2::webshot(html_file, file = pdf_file)
```

```{r Comparation with BLAST}
#top5_UNITE22 <- as.data.frame(read_xlsx("Libro1.xlsx", col_names=TRUE, sheet = 1))
head(top5_UNITE22)

ggplot(top5_UNITE22, aes(fill=Family2, y=Count, x=TRAT2)) + 
    geom_bar(position="stack", stat="identity")

top5_UNITE23 <- as.data.frame(read_xlsx("Libro1.xlsx", col_names=TRUE, sheet = 2))
```

```{r Rarefaction curves}
devtools::install_github("gauravsk/ranacapa")

plot <- ranacapa::ggrare(ps1, step = 100, label = NULL, color = "ID", se = TRUE)
#(plot <- plot + facet_wrap(~TRAT2))
#ggsave("rarefactionps3.png")
```

*NMDS (Non-Metric Multidimensional Scaling)*
-A non-linear non-metric ordination technique.
-Ranks distances rather than preserving actual values.
-Only assumes that rank order of distances is meaningful.
-Axes are arbitrary and do not have intrinsic meaning.
-The distance between points is only relative (ordinal).
Best use case: When working with non-Euclidean distances (e.g., Bray-Curtis) and non-normal ecological data.
游릭 Advantages:
More robust for ecological data with non-linear patterns.
Works well with Bray-Curtis and other ecological dissimilarity metrics.
游댮 Disadvantages:
Cannot directly compare axes across different NMDS runs.
Stress values must be interpreted to determine fit (stress < 0.2 is acceptable, < 0.1 is ideal).

- We can use the vegdist function to calculate our distance matrix if we need it for further analysis, but the *metaMDS function* will automatically calculate the distance matrix based on the type of distance we choose.

```{r NMDS}
OTU.ord <- ordinate(ps_hel, "NMDS", "bray")

ps_hel_meta_data <- data.frame(sample_data(ps_hel))  # Get the metadata from the ps object

ps_hel_meta_data <- ps_hel_meta_data %>% 
  mutate(Fe_g_Kg = Fe_mg_Kg_105/1000,
         Ergosterol_췃g_g = Ergosterol_ng_g_105/1000,
         C_N_ratio = Ctotal_g_100g_105/Ntotal_g_100g_105)

plot_vars <- c("Slope_per","Organic_layer_mean_depth_cm", "Charred_organic_layer_mean_cm", "Green_per", "Brown_per", "Consumed_per", "Grass_per", "Old_litter_per", "New_litter_per", "Mineral_per", "Ash_per", "Stone_per")

env_df <- ps_hel_meta_data %>%
  dplyr::select(all_of(plot_vars))

env2_df <- ps_hel_meta_data %>%
  dplyr::select(all_of(chem_vars))

envfit_results  <- vegan::envfit(OTU.ord, env2_df, permutations = 999, na.rm = TRUE)

env_coord_sig0 <- scores(envfit_results, "vectors")[envfit_results$vectors$pvals < 0.01, ] #Only the significant variables

# Plot the ordination and add the environmental vectors
plot_ordination(ps_hel, OTU.ord, color = "TRAT2") +
  geom_point(size = 4) +  # Adjust point size
  geom_polygon(alpha = 0.2) +
  scale_fill_manual(values = cols) + 
  scale_colour_manual(values = cols) +
  geom_segment(data = as.data.frame(env_coord_sig0), 
               aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
               arrow = arrow(type = "open", length = unit(0.2, "inches")), 
               size = 1, color = "blue") +
  geom_text(data = as.data.frame(env_coord_sig0), 
            aes(x = NMDS1, y = NMDS2, label = rownames(env_coord_sig0)),
            size = 3, color = "blue") +
  theme_minimal()
#ggsave("nmds_hel.png")

#####TOPSOIL


# Perform ordination for topsoil samples
OTU.ord_topsoil <- ordinate(ps_hel_topsoil, method = "NMDS", distance = "bray")

#Add environmental data
env_df_TOP <- ps_hel_meta_data %>%
  filter(DEPTH == "topsoil") %>%
  dplyr::select(all_of(chem_vars))

envfit_TOP  <- vegan::envfit(OTU.ord_topsoil, env_df_TOP, permutations = 999, na.rm = TRUE)

envfit_TOP_sig <- scores(envfit_TOP, "vectors")[envfit_TOP$vectors$pvals < 0.01, ] #Only the significant variables

# Plot the ordination and add the environmental vectors
plot_ordination(ps_hel, OTU.ord_topsoil, color = "TRAT2") +
  geom_point(size = 4) +  # Adjust point size
  geom_polygon(alpha = 0.1) +
  scale_fill_manual(values = cols) + 
  scale_colour_manual(values = cols) +
  geom_segment(data = as.data.frame(envfit_TOP_sig), 
               aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
               arrow = arrow(type = "open", length=unit(0.06, "npc")), 
               size = 1, color = "#737373") +
  geom_text(data = as.data.frame(envfit_TOP_sig), 
            aes(x = NMDS1, y = NMDS2, label = rownames(envfit_TOP_sig)),
            size = 3, color = "#737373") +
  scale_x_reverse()+
    theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("nmdsTOP_chem.png")

#####SUBSOIL
ps_hel_subsoil <- subset_samples(ps_hel, DEPTH == "subsoil")

# Perform ordination for subsoil samples
OTU.ord_subsoil <- ordinate(ps_hel_subsoil, method = "NMDS", distance = "bray")

env_df_SUB <- ps_hel_meta_data %>%
  filter(DEPTH == "subsoil") %>%
  dplyr::select(all_of(chem_vars))

envfit_SUB  <- vegan::envfit(OTU.ord_subsoil, env_df_SUB, permutations = 999, na.rm = TRUE)

envfit_SUB_sig <- scores(envfit_SUB, "vectors")[envfit_SUB$vectors$pvals < 0.01, ] #Only the significant variables

# Plot the ordination and add the environmental vectors
plot_ordination(ps_hel, OTU.ord_subsoil, color = "TRAT2") +
  geom_point(size = 4) +  # Adjust point size
  geom_polygon(alpha = 0.2) +
  scale_fill_manual(values = cols) + 
  scale_colour_manual(values = cols) +
  geom_segment(data = as.data.frame(envfit_SUB_sig), 
               aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
               arrow = arrow(type = "open", length = unit(0.06, "inches")), 
              size = 1, color = "#737373") +
  geom_text(data = as.data.frame(envfit_SUB_sig), 
            aes(x = NMDS1, y = NMDS2, label = rownames(envfit_SUB_sig)),
            size = 3, color = "#737373") +
  #scale_x_reverse()+
  theme(
    panel.background = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.grid = element_blank(),
    axis.text.x = element_text(size = 14),  # Change this value as needed
    axis.text.y = element_text(size = 14),
    legend.position = "none"
  )
#ggsave("nmdsSUB_chem.png")
```

